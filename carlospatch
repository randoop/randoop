### Eclipse Workspace Patch 1.0
#P jrandoop
Index: src/randoop/experiments/RandoopAllClasses.java
===================================================================
RCS file: /afs/csail.mit.edu/u/c/cpacheco/cvs/jrandoop/src/randoop/experiments/RandoopAllClasses.java,v
retrieving revision 1.11
diff -u -r1.11 RandoopAllClasses.java
--- src/randoop/experiments/RandoopAllClasses.java	29 Aug 2008 19:04:15 -0000	1.11
+++ src/randoop/experiments/RandoopAllClasses.java	30 Aug 2008 23:52:28 -0000
@@ -121,12 +121,12 @@
       randoop.add("--use-object-cache");
       randoop.add("--alias-ratio=0.5");
     }
-    randoop.add("--maxsize=200");
+    randoop.add("--maxsize=40");
     randoop.add("--randomseed=" + seed);
     //randoop.add("--output-components=" + exp.experimentName + ".components.gz");
     randoop.add("--output-covmap=" + exp.experimentName + ".covmap.gz");
     randoop.add("--randoop-exp");
-    randoop.add("--dontexecute");
+    randoop.add("--filter-short-dep=10");
 
 
     ExperimentBase.printCommand(randoop, false, true);
Index: src/randoop/DependencyUtils.java
===================================================================
RCS file: /afs/csail.mit.edu/u/c/cpacheco/cvs/jrandoop/src/randoop/DependencyUtils.java,v
retrieving revision 1.1
diff -u -r1.1 DependencyUtils.java
--- src/randoop/DependencyUtils.java	29 Aug 2008 15:12:43 -0000	1.1
+++ src/randoop/DependencyUtils.java	30 Aug 2008 23:52:28 -0000
@@ -1,6 +1,7 @@
 package randoop;
 
 import java.util.ArrayList;
+import java.util.BitSet;
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
@@ -56,4 +57,76 @@
     return news;
   }
   
+  private static BitSet[] sets;
+  private static int[] lastuse;
+  private static int maxlength = 300; // TODO paramterize.
+  static {
+    sets = new BitSet[maxlength];
+    for (int i = 0 ; i < maxlength ; i++) {
+      sets[i] = new BitSet(i+1);
+    }
+    lastuse = new int[maxlength];
+  }
+  
+  /**
+   * The longest dep set of the sub-sequence s[0..idx].
+   */
+  public static BitSet longestDepSet(Sequence s, int idx) {
+    if (s.size() == 0) throw new IllegalArgumentException("size must be greater than 0.");
+    if (idx < 0 || idx >= s.size()) throw new IllegalArgumentException();
+    assert s.size() <= maxlength;
+    int max = -1;
+    int maxidx = -1;
+    for (int i = 0 ; i <= idx ; i++) {
+      BitSet set = sets[i];
+      set.clear();
+      set.set(i);
+      lastuse[i] = i;
+      for (Variable invar : s.getInputs(i)) {
+        set.or(sets[lastuse[invar.index]]);
+        lastuse[invar.index] = i;
+      }
+      int size = set.cardinality();
+      if (size > max) {
+        max = size;
+        maxidx = i;
+      }
+    }
+    for (int i = 0 ; i < s.size() ; i++) {
+      //System.out.println("@ " + sets[i]);
+    }
+    return sets[maxidx];
+  }
+  
+  public static BitSet longestDepSet(Sequence s) {
+    return longestDepSet(s, s.size() - 1);
+  }
+  
+  public static Sequence getLongestDepSetSubSequence(Sequence s) {
+    BitSet indices = longestDepSet(s, s.size() - 1);
+    int length = indices.length();
+    assert indices.get(length - 1);
+
+    Map<Integer,Integer> newIdx = new LinkedHashMap<Integer,Integer>();
+    int count = 0;
+    for (int i = 0 ; i < length ; i++) {
+      if (!indices.get(i))
+        continue;
+      newIdx.put(i, count++);
+    }
+    
+    Sequence news = new Sequence();
+    for (int i = 0 ; i < length ; i++) {
+      if (!indices.get(i))
+        continue;
+      List<Variable> oldins = s.getInputs(i);
+      List<Variable> newins = new ArrayList<Variable>(oldins.size());
+      for (Variable oldv : oldins) {
+        newins.add(news.getVariable(newIdx.get(oldv.index)));
+      }
+      news = news.extend(s.getStatementKind(i), newins);
+    }
+    return news;
+  }
+  
 }
Index: src/randoop/Sequence.java
===================================================================
RCS file: /afs/csail.mit.edu/u/c/cpacheco/cvs/jrandoop/src/randoop/Sequence.java,v
retrieving revision 1.15
diff -u -r1.15 Sequence.java
--- src/randoop/Sequence.java	29 Aug 2008 19:04:15 -0000	1.15
+++ src/randoop/Sequence.java	30 Aug 2008 23:52:28 -0000
@@ -8,10 +8,8 @@
 import java.util.BitSet;
 import java.util.Collection;
 import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 
 import randoop.util.ArrayListSimpleList;
 import randoop.util.ListOfLists;
@@ -148,17 +146,13 @@
     return b.toString();
   }
 
-  public String toDotString() {
-    return toModifiableSequence().toDotString();
-  }
-
   /**
    * Equivalent to toParseableString().
    */
   public String toString() {
     return toParseableString();
   }
-
+  
   // A set of bits, where there is one bit associated with each index.
   // Active flags are used during generation, to determine what values
   // in an existing sequence are useful to be used as inputs when
@@ -843,6 +837,15 @@
    * For a dicussion of performance, see note in class-level documentation.
    */
   public String toParseableString() {
+    return toParseableString(Globals.lineSep);
+  }
+  
+  /**
+   * Like toParseableString, but the client can specify a string that
+   * will be used a separator between statements.
+   */
+  public String toParseableString(String statementSep) {
+    assert statementSep != null;
     StringBuilder b = new StringBuilder();
     for (int i = 0; i < size(); i++) {
       b.append("var" + i);
@@ -856,9 +859,9 @@
         b.append(v.toString());
         b.append(" ");
       }
-      b.append(Globals.lineSep);
+      b.append(statementSep);
     }
-    return b.toString();
+    return b.toString();  
   }
 
   /**
@@ -999,4 +1002,22 @@
     RecordListReader reader = new RecordListReader("SEQUENCE", processor);
     reader.parse(file);
   }
+  
+
+  public int lastUseBefore(int idx, Variable var) {
+    if (var.sequence != this)
+      throw new IllegalArgumentException("variable does not belong to sequence.");
+    for (int i = idx - 1 ; i >= 0 ; i--) {
+      if (getVariable(i).equals(var)) {
+        return i;
+      }
+      for (Variable input : getInputs(i)) {
+        if (input.equals(var)) {
+          return i;
+        }
+      }
+    }
+    throw new IllegalStateException("Bug in Randoop.");
+  }
+  
 }
Index: src/randoop/ExpressionThrowsException.java
===================================================================
RCS file: src/randoop/ExpressionThrowsException.java
diff -N src/randoop/ExpressionThrowsException.java
--- src/randoop/ExpressionThrowsException.java	4 Aug 2008 19:18:23 -0000	1.4
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,72 +0,0 @@
-package randoop;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Records the fact that an expression, when evaluated, results in
- * an exception.
- */
-public class ExpressionThrowsException implements ContractViolation {
-
-  // The expression whose runtime value this observation records.
-  public Class<? extends ObjectContract> objcontract;
-
-  // The variables over which the expression applies.
-  public List<Variable> vars;
-
-  // The kind of exception that the expression throws.
-  private final Class<? extends Throwable> exceptionClass;
-  
-  public String toString() {
-    StringBuilder b = new StringBuilder();
-    b.append("ContractViolation:throws-exception-");
-    b.append(objcontract);
-    b.append(vars);
-    return b.toString();
-  }
-
-
-  public ExpressionThrowsException(Class<? extends ObjectContract> expression,
-      List<Variable> vars, Throwable exception) {
-    this.objcontract = expression;
-    this.vars = new ArrayList<Variable>(vars);
-    if (exception == null)
-      throw new IllegalArgumentException("exception cannot be null.");
-    this.exceptionClass = exception.getClass();
-  }
-
-
-  public String toCodeStringPreStatement() {
-    return "";
-  }
-
-  public String toCodeStringPostStatement() {
-    StringBuilder b = new StringBuilder();
-    b.append(Globals.lineSep);
-    b.append("// Checks " + ExpressionUtils.localizeExpressionComment(objcontract, vars) + Globals.lineSep);
-    b.append("try {" + Globals.lineSep + "  ");
-    
-    String codeStr = null;
-    try {
-      codeStr = objcontract.newInstance().toCodeString();
-    } catch (Exception e) {
-      throw new Error(e);
-    }
-    if (codeStr == null) {
-      b.append("  " + ExpressionUtils.toCodeString(objcontract, vars));
-    } else {
-      b.append("  " + ExpressionUtils.localizeExpressionCode(objcontract, vars));
-    }
-    b.append(";" + Globals.lineSep);
-    String exceptionClassName = exceptionClass.getCanonicalName();
-    b.append("} catch (");
-    b.append(exceptionClassName);
-    b.append(" e) {" + Globals.lineSep);
-    b.append("  fail(\"Unexpected exception: \" + e.toString());" + Globals.lineSep);
-    b.append("}" + Globals.lineSep);
-
-    return b.toString();
-  }
-
-}
Index: src/randoop/MSequence.java
===================================================================
RCS file: /afs/csail.mit.edu/u/c/cpacheco/cvs/jrandoop/src/randoop/MSequence.java,v
retrieving revision 1.8
diff -u -r1.8 MSequence.java
--- src/randoop/MSequence.java	27 Aug 2008 14:35:15 -0000	1.8
+++ src/randoop/MSequence.java	30 Aug 2008 23:52:28 -0000
@@ -192,48 +192,6 @@
     return toImmutableSequence().toCodeString();
   }
 
-
-  public String toDotString() {
-    return toDotString(size() - 1);
-  }
-
-  public String toDotString(int maxIdx) {
-    StringBuilder b = new StringBuilder();
-    b.append("digraph G {\n");
-    for (int i = 0; i <= maxIdx; i++) {
-      MStatement st = statements.get(i);
-      if (st.statementKind instanceof PrimitiveOrStringOrNullDecl) {
-        continue;
-      } else if (st.inputs.isEmpty()) {
-        b.append("s" + i + ";\n");
-      } else {
-        for (MVariable input : st.inputs) {
-          if (statements.get(input.getDeclIndex()).statementKind
-              instanceof PrimitiveOrStringOrNullDecl) {
-            continue;
-          }
-          b.append("s" + lastAppearanceBefore(i, input) + " -> " + "s" + i + ";\n");
-        }
-      }
-    }
-    b.append("}\n");
-    return b.toString();
-  }
-
-  private int lastAppearanceBefore(int idx, MVariable var) {
-    for (int i = idx - 1 ; i >= 0 ; i--) {
-      if (statements.get(i).result.equals(var)) {
-        return i;
-      }
-      for (MVariable input : statements.get(i).inputs) {
-        if (input.equals(var)) {
-          return i;
-        }
-      }
-    }
-    throw new IllegalStateException("Bug in Randoop.");
-  }
-
   /**
    * inserts the statements making up the given sequence into this sequence, at
    * the given index. The parameter sequence is left unchanged. The receiver
Index: src/randoop/AbstractGenerator.java
===================================================================
RCS file: /afs/csail.mit.edu/u/c/cpacheco/cvs/jrandoop/src/randoop/AbstractGenerator.java,v
retrieving revision 1.7
diff -u -r1.7 AbstractGenerator.java
--- src/randoop/AbstractGenerator.java	27 Aug 2008 14:44:26 -0000	1.7
+++ src/randoop/AbstractGenerator.java	30 Aug 2008 23:52:28 -0000
@@ -1,5 +1,6 @@
 package randoop;
 
+import java.io.IOException;
 import java.text.DecimalFormat;
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
@@ -10,6 +11,8 @@
 
 import randoop.Globals;
 import randoop.SequenceGeneratorStats;
+import randoop.experiments.SizeEqualizer;
+import randoop.experiments.StatsWriter;
 import randoop.main.GenInputsAbstract;
 import randoop.util.Files;
 import randoop.util.Log;
@@ -37,6 +40,7 @@
   public SequenceGeneratorStats stats;
   public List<Class<?>> covClasses;
   public SequenceCollection seeds;
+  public SizeEqualizer sizeEqualizer = new SizeEqualizer();
 
   /**
    *
@@ -54,6 +58,7 @@
     this.maxSequences = maxSequences;
 
     this.statements = statements;
+    
     if (covClasses == null)
       this.covClasses = new ArrayList<Class<?>>();
     else
@@ -119,8 +124,19 @@
         if (eSeq == null)
           continue;
 
+        if (GenInputsAbstract.expfile != null) {
+          try {
+            if (!GenInputsAbstract.size_equalizer
+                || sizeEqualizer.add(eSeq)) {
+              StatsWriter.write(GenInputsAbstract.expfile, eSeq, cov);
+            }
+          } catch (IOException e) {
+            throw new Error(e);
+          }
+        }
+        
         stats.updateStatistics(eSeq, cov);
-
+        
         if (Log.isLoggingOn()) {
           Log.logLine("Sequence after execution: " + Globals.lineSep + eSeq.toString());
           Log.logLine("allSequences.size()=" + numSequences());
Index: src/randoop/NaiveRandomGenerator.java
===================================================================
RCS file: /afs/csail.mit.edu/u/c/cpacheco/cvs/jrandoop/src/randoop/NaiveRandomGenerator.java,v
retrieving revision 1.13
diff -u -r1.13 NaiveRandomGenerator.java
--- src/randoop/NaiveRandomGenerator.java	29 Aug 2008 19:04:15 -0000	1.13
+++ src/randoop/NaiveRandomGenerator.java	30 Aug 2008 23:52:28 -0000
@@ -150,8 +150,6 @@
     extendRandomly();
     if (Log.isLoggingOn()) Log.logLine("EXTENDED SEQUENCE: " + sequence.toString());
 
-    update();
-
     logState();
 
     numSeqs++;
@@ -171,21 +169,6 @@
       }
     }
 
-
-    if (GenInputsAbstract.offline) {
-      // We may exceed seqence size because of primitive declarations.
-      if (sequence.size() >= GenInputsAbstract.maxsize) {
-        ExecutableSequence ret = executeWhole();
-        resetState();
-        return ret;
-      } else {
-        //update();
-        return null;
-      }
-    }
-
-    assert !GenInputsAbstract.offline;
-
     ExecutableSequence eseq =
       new ExecutableSequence(sequence, new Execution(sequence, exec), obs);
 
@@ -220,10 +203,11 @@
     }
 
     if (exec.get(last) instanceof ExceptionalExecution) {
-      if (!undoLastStep()) {
-        resetState();
-      }
-      return null;
+      ExecutableSequence ret = new ExecutableSequence(sequence,
+          new Execution(sequence, new ArrayList<ExecutionOutcome>(exec)),
+          new ArrayList<List<Observation>>(obs));
+      resetState();
+      return ret;
     }
 
     if (eseq.hasObservation(ContractViolation.class)) {
@@ -233,9 +217,7 @@
           new Execution(sequence, new ArrayList<ExecutionOutcome>(exec)),
           new ArrayList<List<Observation>>(obs));
 
-      if (!undoLastStep()) {
-        resetState();
-      }
+      resetState();
       return ret;
     }
 
@@ -250,11 +232,41 @@
       resetState();
       return ret;
     }
-
-    //update();
+    
+    if (((NormalExecution)eseq.getResult(last)).getRuntimeValue() != null) { 
+      update();
+    }
 
     return null;
   }
+  
+
+
+//  if (GenInputsAbstract.offline) {
+//    // We may exceed seqence size because of primitive declarations.
+//    if (sequence.size() >= GenInputsAbstract.maxsize) {
+//      
+//      if (GenInputsAbstract.filter_short_dep != null) {
+//        Sequence s = DependencyUtils.getLongestDepSetSubSequence(sequence);
+//        if (s.size() < GenInputsAbstract.filter_short_dep) {
+//          resetState();
+//          return null;
+//        } else {
+//          sequence = s;
+//          ExecutableSequence ret = executeWhole();
+//          resetState();
+//          return ret;
+//        }
+//      }
+//      
+//      ExecutableSequence ret = executeWhole();
+//      resetState();
+//      return ret;
+//    } else {
+//      //update();
+//      return null;
+//    }
+//  }
 
   private void update() {
     Class<?> retType = sequence.getLastStatement().getOutputType();
@@ -382,7 +394,19 @@
 
     ExecutableSequence eseq = new ExecutableSequence(sequence);
     eseq.execute(executionVisitor);
-
+    
+    int firstNonExec = 0;
+    for (int i = 0 ; i < eseq.sequence.size() ; i++) {
+      if (eseq.getResult(i) instanceof NotExecuted) {
+        firstNonExec = i;
+        break;
+      }
+    }
+    
+    if (firstNonExec > 40 ) {
+       System.out.println(">>>");
+       System.out.println(eseq.toDotString());
+    }
 
     int failureIdx = eseq.getObservationIndex(ContractViolation.class);
 
Index: src/randoop/ContractViolation.java
===================================================================
RCS file: /afs/csail.mit.edu/u/c/cpacheco/cvs/jrandoop/src/randoop/ContractViolation.java,v
retrieving revision 1.1
diff -u -r1.1 ContractViolation.java
--- src/randoop/ContractViolation.java	20 Jul 2008 18:56:54 -0000	1.1
+++ src/randoop/ContractViolation.java	30 Aug 2008 23:52:28 -0000
@@ -2,5 +2,9 @@
 
 public interface ContractViolation extends Observation {
 
+  String toStringName();
+
+  String toStringVars();
+
 
 }
Index: src/randoop/SequenceGeneratorStats.java
===================================================================
RCS file: /afs/csail.mit.edu/u/c/cpacheco/cvs/jrandoop/src/randoop/SequenceGeneratorStats.java,v
retrieving revision 1.11
diff -u -r1.11 SequenceGeneratorStats.java
--- src/randoop/SequenceGeneratorStats.java	27 Aug 2008 19:25:28 -0000	1.11
+++ src/randoop/SequenceGeneratorStats.java	30 Aug 2008 23:52:28 -0000
@@ -438,7 +438,7 @@
 
             System.out.println(es.toCodeString());
 
-            System.out.println(es.sequence.toDotString());
+            System.out.println(es.toDotString());
 
           }
 
Index: src/randoop/ExpressionEqFalse.java
===================================================================
RCS file: /afs/csail.mit.edu/u/c/cpacheco/cvs/jrandoop/src/randoop/ExpressionEqFalse.java,v
retrieving revision 1.3
diff -u -r1.3 ExpressionEqFalse.java
--- src/randoop/ExpressionEqFalse.java	4 Aug 2008 19:18:24 -0000	1.3
+++ src/randoop/ExpressionEqFalse.java	30 Aug 2008 23:52:28 -0000
@@ -89,5 +89,13 @@
       return b.toString();
     }
 
+    public String toStringName() {
+      return objcontract.getSimpleName();
+    }
+
+    public String toStringVars() {
+      return vars.toString();
+    }
+
  
 }
Index: src/randoop/StatementThrowsNPE.java
===================================================================
RCS file: /afs/csail.mit.edu/u/c/cpacheco/cvs/jrandoop/src/randoop/StatementThrowsNPE.java,v
retrieving revision 1.1
diff -u -r1.1 StatementThrowsNPE.java
--- src/randoop/StatementThrowsNPE.java	27 Aug 2008 14:35:13 -0000	1.1
+++ src/randoop/StatementThrowsNPE.java	30 Aug 2008 23:52:28 -0000
@@ -44,4 +44,12 @@
     b.append("}" + Globals.lineSep);
     return b.toString();
   }
+
+  public String toStringName() {
+    return "npe";
+  }
+
+  public String toStringVars() {
+    return "[]";
+  }
 }
Index: src/randoop/ExecutableSequence.java
===================================================================
RCS file: /afs/csail.mit.edu/u/c/cpacheco/cvs/jrandoop/src/randoop/ExecutableSequence.java,v
retrieving revision 1.12
diff -u -r1.12 ExecutableSequence.java
--- src/randoop/ExecutableSequence.java	29 Aug 2008 19:04:15 -0000	1.12
+++ src/randoop/ExecutableSequence.java	30 Aug 2008 23:52:28 -0000
@@ -313,6 +313,20 @@
     }
     return ret;
   }
+  
+  /**
+   * @return the number of elements in the sequence that were executed before
+   * an execution result of type randoop.NotExecuted.
+   */
+  public int executedSize() {
+    int count = 0;
+    for ( ; count < executionResults.size(); count++) {
+      if (executionResults.get(count) instanceof NotExecuted) {
+        break;
+      }
+    }
+    return count;
+  }
 
   /**
    * This method is typically used by ExecutionVisitors.
@@ -552,4 +566,53 @@
 
     return true;
   }
+
+  public String toDotString() {
+    StringBuilder b = new StringBuilder();
+
+    b.append("digraph G {\n");
+    
+    for (int i = 0 ; i < sequence.size() ; i++) {
+      b.append("s" + i + " [color=" + getColor(i) + ",style=filled];\n"); 
+    }
+
+    for (int i = 0; i < sequence.size() ; i++) {
+      StatementKind st = sequence.getStatementKind(i);
+      List<Variable> inputs = sequence.getInputs(i);
+      if (st instanceof PrimitiveOrStringOrNullDecl) {
+        continue;
+      }
+      if (inputs.isEmpty()) {
+        continue;
+      } 
+      for (Variable input : inputs) {
+        if (sequence.getStatementKind(input.getDeclIndex())
+            instanceof PrimitiveOrStringOrNullDecl) {
+          continue;
+        }
+        b.append("s" + sequence.lastUseBefore(i, input) + " -> " + "s" + i + ";\n");
+      }
+    }
+    b.append("}\n");
+    return b.toString();
+  }
+
+  private String getColor(int i) {
+    ExecutionOutcome res = getResult(i);
+    if (res instanceof NotExecuted) {
+      return "white";
+    } else if (res instanceof ExceptionalExecution) {
+      return "yellow";
+    } else {
+      assert res instanceof NormalExecution;
+      if (hasObservation(i, StatementThrowsNPE.class)) {
+        return "brown";
+      } else if (hasObservation(i, ExpressionEqFalse.class)) {
+        return "red";
+      } else {
+        return "green";
+      }
+    }
+  }
+
 }
Index: src/randoop/util/ClassComplexityCalculator.java
===================================================================
RCS file: /afs/csail.mit.edu/u/c/cpacheco/cvs/jrandoop/src/randoop/util/ClassComplexityCalculator.java,v
retrieving revision 1.3
diff -u -r1.3 ClassComplexityCalculator.java
--- src/randoop/util/ClassComplexityCalculator.java	7 Jul 2008 23:32:19 -0000	1.3
+++ src/randoop/util/ClassComplexityCalculator.java	30 Aug 2008 23:52:28 -0000
@@ -141,7 +141,7 @@
     Histogram<Class<?>> h= new Histogram<Class<?>>();
     for (Class<?> c : classes) {
       //System.out.println((count++) + " of " + classes.size());
-      h.count(c, ccc.classComplexity(c));
+      h.addToCount(c, ccc.classComplexity(c));
     }
     System.out.println(h.toStringSortedByNumbers());
   }
Index: src/randoop/util/Histogram.java
===================================================================
RCS file: /afs/csail.mit.edu/u/c/cpacheco/cvs/jrandoop/src/randoop/util/Histogram.java,v
retrieving revision 1.3
diff -u -r1.3 Histogram.java
--- src/randoop/util/Histogram.java	27 Aug 2008 14:44:20 -0000	1.3
+++ src/randoop/util/Histogram.java	30 Aug 2008 23:52:28 -0000
@@ -26,7 +26,7 @@
     this(null);
   }   
 
-  public void count(T t, int i){
+  public void addToCount(T t, int i){
     if (i <= 0)
       throw new IllegalArgumentException("negative argument:" + i);
     if (! fMap.containsKey(t))
@@ -35,8 +35,8 @@
       fMap.put(t, getCount(t) + i);
   }
 
-  public void count(T t){
-    count(t, 1);
+  public void addOneToCount(T t){
+    addToCount(t, 1);
   }
 
   @Override
@@ -99,7 +99,7 @@
     return result;
   }
 
-  public int getCount(Object t){
+  public int getCount(T t){
     if (fMap.containsKey(t))
       return fMap.get(t);
     else return 0;
Index: tests/randoop/test/DependencyTests.java
===================================================================
RCS file: /afs/csail.mit.edu/u/c/cpacheco/cvs/jrandoop/tests/randoop/test/DependencyTests.java,v
retrieving revision 1.1
diff -u -r1.1 DependencyTests.java
--- tests/randoop/test/DependencyTests.java	29 Aug 2008 15:12:42 -0000	1.1
+++ tests/randoop/test/DependencyTests.java	30 Aug 2008 23:52:28 -0000
@@ -36,6 +36,10 @@
       Sequence output = outputs.get(i);
       
       Sequence pred = DependencyUtils.predecessorSequence(input, index);
+      
+      System.out.println(DependencyUtils.longestDepSet(input));
+      System.out.println(">>" + DependencyUtils.longestDepSet(input));
+      System.out.println(">>>" + DependencyUtils.getLongestDepSetSubSequence(input));
 
       String msg = "\nFAILURE ON INPUT " + i + "\n\n" +
       "INDEX:" + index + 
Index: src/randoop/main/GenInputsAbstract.java
===================================================================
RCS file: /afs/csail.mit.edu/u/c/cpacheco/cvs/jrandoop/src/randoop/main/GenInputsAbstract.java,v
retrieving revision 1.18
diff -u -r1.18 GenInputsAbstract.java
--- src/randoop/main/GenInputsAbstract.java	29 Aug 2008 19:04:16 -0000	1.18
+++ src/randoop/main/GenInputsAbstract.java	30 Aug 2008 23:52:28 -0000
@@ -1,6 +1,7 @@
 package randoop.main;
 
 import java.io.File;
+import java.io.FileWriter;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.regex.Pattern;
@@ -20,6 +21,15 @@
   public final static String pass = "pass";
 
   @Invisible
+  @Option("Has to do with experiments...")
+  public static boolean size_equalizer = false;
+
+  
+  @Invisible
+  @Option("Write experiment results file.")
+  public static FileWriter expfile = null;
+  
+  @Invisible
   @Option("Works only with naive offline. ")
   public static Integer filter_short_dep = null;
 
Index: src/randoop/experiments/StatsWriter.java
===================================================================
RCS file: src/randoop/experiments/StatsWriter.java
diff -N src/randoop/experiments/StatsWriter.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/randoop/experiments/StatsWriter.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,149 @@
+package randoop.experiments;
+
+import java.io.BufferedReader;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.List;
+import java.util.Set;
+
+import randoop.ContractViolation;
+import randoop.DependencyUtils;
+import randoop.ExecutableSequence;
+import randoop.Observation;
+import randoop.util.Histogram;
+import utilpag.Pair;
+import utilpag.UtilMDE;
+import cov.Branch;
+
+public class StatsWriter {
+  
+
+  private static int recordsread = 0;
+  private static int lines = 0;
+  
+  public static void write(FileWriter writer, ExecutableSequence seq, Set<Branch> cov) throws IOException {
+    StringBuilder b = new StringBuilder();
+    
+    // Number of executed statements ("real" size).
+    b.append(seq.executedSize() + "\n");
+    
+    // Length of longest dependency set.
+    b.append(DependencyUtils.longestDepSet(seq.sequence, seq.executedSize() - 1).cardinality() + "\n");
+
+    // Sequence.
+    b.append(seq.sequence.toParseableString(";"));
+    b.append("\n");
+    
+    // Branches covered.
+    for (Branch br : cov) {
+      b.append(br + " ");
+    }
+    b.append("\n");
+    
+    // Compute classifications.
+    StringBuilder classif = new StringBuilder();
+    int numclassifications = 0;
+    int idx = seq.getObservationIndex(ContractViolation.class);
+    if (idx >= 0) {
+      List<Observation> vios = seq.getObservations(idx, ContractViolation.class);
+      for (Observation obs : vios) {
+        ContractViolation vio = (ContractViolation)obs;
+        classif.append(vio.toStringName() + "\n");
+        classif.append(vio.toStringVars() + "\n");
+        numclassifications++;
+      }
+    } else if (seq.isNormalExecution()) {
+      classif.append("normal\n\n");
+      numclassifications = 1;
+    } else {
+      idx = seq.getExceptionIndex(Throwable.class);
+      assert idx >= 0 : seq;
+      classif.append("exception\n\n");
+      numclassifications = 1;
+    }
+    
+    // Number of classifications.
+    b.append(numclassifications + "\n");
+    
+    // Classifications.
+    b.append(classif.toString());
+    
+    writer.write(b.toString());
+  }
+
+  private static int maxclassifs = 10;
+  public int size = -1;
+  public int depsize = -1;
+  public String seq_str = null;
+  public String branches_str = null;
+  public int numclassifs = -1;
+  public String[] classifNames = new String[maxclassifs];
+  public String[] classifVars = new String[maxclassifs];
+  
+  public boolean read(BufferedReader reader, StatsComputer comp) throws IOException {
+    recordsread++;
+    String line = null;
+    try {
+
+      // Number of executed statements.
+      size = Integer.parseInt(readLine(reader));
+
+      // Length of longest dependency set.
+      depsize = Integer.parseInt(readLine(reader));
+
+      // Sequence
+      seq_str = readLine(reader);
+      
+      // Branches
+      branches_str = readLine(reader);
+      
+      numclassifs = Integer.parseInt(readLine(reader));
+      for (int i = 0 ; i < numclassifs ; i++) {
+
+        // Read one classification.
+        // Read name.
+        classifNames[i] = readLine(reader);
+        // Read vars.
+        classifVars[i] = readLine(reader);
+      }
+      
+    } catch (EndOfFile e) {
+      return false;
+    } catch (Exception e) {
+      System.out.println("Error while reading line:" + line);
+      System.out.println("(records read=" + recordsread + ", lines = " + lines + ")");
+      throw new Error(e);
+    }
+
+    comp.processOneRecord(this);
+    return true;
+  }
+  
+  private static String readLine(BufferedReader reader) throws EndOfFile, IOException {
+    String ret = reader.readLine();
+    lines++;
+    if (ret == null) {
+      throw new EndOfFile();
+    }
+    return ret;
+  }
+  
+  public static void main(String[] args) throws IOException {
+    
+    StatsWriter s = new StatsWriter();
+    StatsComputer comp = new TempStatsComputer();
+    
+    BufferedReader br = UtilMDE.bufferedFileReader(args[0]);
+    for (;;)
+     if (!s.read(br, comp)) {
+       break;
+    }
+   
+    System.out.println("Read " + recordsread + " records.");
+    System.out.println(comp.results());
+  }
+  
+  public static class EndOfFile extends Exception {
+    private static final long serialVersionUID = 1L;
+  }
+}
Index: systemtests/carlos_analysis.txt
===================================================================
RCS file: systemtests/carlos_analysis.txt
diff -N systemtests/carlos_analysis.txt
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ systemtests/carlos_analysis.txt	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,4312 @@
+
+============================================================
+
+    // Can be reached with the following modified sequence:
+    // This may work by iterating over existing bitset sequences AND
+    // mutating them (to get 1000), then adding them as params.
+
+// START RECORD
+// BRANCH 
+// classname=java2.util2.BitSet,methodname=equals,line=956,id=91,direction=false
+// SEQUENCE
+// var0 =  cons : java2.util2.BitSet.<init>() : 
+// var1 =  prim : int:10 : 
+// var2 =  method : java2.util2.BitSet.flip(int) : var0 var1 
+// var3 =  prim : int:0 : 
+// var4 =  prim : int:10 : 
+// var5 =  method : java2.util2.BitSet.flip(int,int) : var0 var3 var4 
+// var6 =  prim : int:0 : 
+// var7 =  method : java2.util2.BitSet.clear(int) : var0 var6 
+// var8 =  prim : int:0 : 
+// var9 =  prim : int:10 : 
+// var10 =  method : java2.util2.BitSet.get(int,int) : var0 var8 var9 
+// var11 =  prim : int:0 : 
+// var12 =  prim : int:100 : 
+// var13 =  method : java2.util2.BitSet.flip(int,int) : var10 var11 var12 
+// var14 =  prim : int:1 : 
+// var15 =  method : java2.util2.BitSet.set(int) : var10 var14 
+// var16 =  cons : java2.util2.BitSet.<init>() : 
+// var17 =  prim : int:10 : 
+// var18 =  method : java2.util2.BitSet.flip(int) : var16 var17 
+// var19 =  method : java2.util2.BitSet.xor(java2.util2.BitSet) : var10 var16 
+// var20 =  cons : java2.util2.BitSet.<init>() : 
+// x = cons : java2.util2.BitSet.<init>() : 
+// i = prim : int:1000 : 
+// y =  method : java2.util2.BitSet.set(int) : x i
+// var21 =  method : java2.util2.BitSet.equals(java.lang.Object) : x var20 
+
+// END RECORD
+
+
+START RECORD
+BRANCH 
+classname=java2.util2.BitSet,methodname=equals,line=956,id=91,direction=true
+SEQUENCE
+var0 =  cons : java2.util2.BitSet.<init>() : 
+var1 =  prim : int:10 : 
+var2 =  method : java2.util2.BitSet.flip(int) : var0 var1 
+var3 =  prim : int:0 : 
+var4 =  prim : int:10 : 
+var5 =  method : java2.util2.BitSet.flip(int,int) : var0 var3 var4 
+var6 =  prim : int:0 : 
+var7 =  method : java2.util2.BitSet.clear(int) : var0 var6 
+var8 =  prim : int:0 : 
+var9 =  prim : int:10 : 
+var10 =  method : java2.util2.BitSet.get(int,int) : var0 var8 var9 
+var11 =  prim : int:0 : 
+var12 =  prim : int:100 : 
+var13 =  method : java2.util2.BitSet.flip(int,int) : var10 var11 var12 
+var14 =  prim : int:1 : 
+var15 =  method : java2.util2.BitSet.set(int) : var10 var14 
+var16 =  cons : java2.util2.BitSet.<init>() : 
+var17 =  prim : int:10 : 
+var18 =  method : java2.util2.BitSet.flip(int) : var16 var17 
+var19 =  method : java2.util2.BitSet.xor(java2.util2.BitSet) : var10 var16 
+var20 =  cons : java2.util2.BitSet.<init>() : 
+var21 =  method : java2.util2.BitSet.equals(java.lang.Object) : var10 var20 
+
+END RECORD
+
+As source code:
+java2.util2.BitSet var0 = new java2.util2.BitSet();
+java.lang.Integer var1 = new java.lang.Integer((int)10);
+var0.flip((int)var1);
+java.lang.Integer var3 = new java.lang.Integer((int)0);
+java.lang.Integer var4 = new java.lang.Integer((int)10);
+var0.flip((int)var3, (int)var4);
+java.lang.Integer var6 = new java.lang.Integer((int)0);
+var0.clear((int)var6);
+java.lang.Integer var8 = new java.lang.Integer((int)0);
+java.lang.Integer var9 = new java.lang.Integer((int)10);
+java2.util2.BitSet var10 = var0.get((int)var8, (int)var9);
+java.lang.Integer var11 = new java.lang.Integer((int)0);
+java.lang.Integer var12 = new java.lang.Integer((int)100);
+var10.flip((int)var11, (int)var12);
+java.lang.Integer var14 = new java.lang.Integer((int)1);
+var10.set((int)var14);
+java2.util2.BitSet var16 = new java2.util2.BitSet();
+java.lang.Integer var17 = new java.lang.Integer((int)10);
+var16.flip((int)var17);
+var10.xor((java2.util2.BitSet)var16);
+java2.util2.BitSet var20 = new java2.util2.BitSet();
+boolean var21 = var10.equals((java.lang.Object)var20);
+
+Variables: [var14:[0], var17:[0], var11:[0]]
+      /**
+       * Compares this object against the specified object.
+       * The result is <code>true</code> if and only if the argument is 
+       * not <code>null</code> and is a <code>Bitset</code> object that has 
+       * exactly the same set of bits set to <code>true</code> as this bit 
+       * set. That is, for every nonnegative <code>int</code> index <code>k</code>, 
+       * <pre>((BitSet)obj).get(k) == this.get(k)</pre>
+       * must be true. The current sizes of the two bit sets are not compared. 
+       * <p>Overrides the <code>equals</code> method of <code>Object</code>.
+       *
+       * @param   obj   the object to compare with.
+       * @return  <code>true</code> if the objects are the same;
+       *          <code>false</code> otherwise.
+       * @see     java2.util2.BitSet#size()
+       */
+      public boolean equals(Object obj) {
+  	if (!(obj instanceof BitSet))
+  	    return false;
+  	if (this == obj)
+  	    return true;
+  
+  	BitSet set = (BitSet) obj;
+  	int minUnitsInUse = Math.min(unitsInUse, set.unitsInUse);
+  
+  	// Check units in use by both BitSets
+  	for (int i = 0; i < minUnitsInUse; i++)
+  	    if (bits[i] != set.bits[i])
+  		return false;
+  
+  	// Check any units in use by only one BitSet (must be 0 in other)
+  	if (unitsInUse > minUnitsInUse) {
+  	    for (int i = minUnitsInUse; i<unitsInUse; i++)
+>>		if (bits[i] != 0)
+  		    return false;
+  	} else {
+  	    for (int i = minUnitsInUse; i<set.unitsInUse; i++)
+  		if (set.bits[i] != 0)
+  		    return false;
+  	}
+  
+  	return true;
+      }
+
+
+WILL TRY TO REPLACE var14 WITH var11
+WILL TRY TO REPLACE var17 WITH var11
+WILL TRY TO REPLACE var17 WITH var14
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=equals,line=956,id=91,direction=false
+WILL TRY REPLACING var14 WITH VALUE 0
+WILL TRY NEGATING var14
+WILL TRY SETTING TO ZERO var14
+WILL TRY ADDING 1 var14
+WILL TRY SUBTRACTING 1 var14
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=equals,line=956,id=91,direction=false
+WILL TRY REPLACING var17 WITH VALUE 0
+WILL TRY NEGATING var17
+WILL TRY SETTING TO ZERO var17
+WILL TRY ADDING 1 var17
+WILL TRY SUBTRACTING 1 var17
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=equals,line=956,id=91,direction=false
+WILL TRY REPLACING var11 WITH VALUE 0
+WILL TRY NEGATING var11
+WILL TRY SETTING TO ZERO var11
+WILL TRY ADDING 1 var11
+WILL TRY SUBTRACTING 1 var11
+FAILURE
+
+===============================================================
+
+    // TODO
+
+START RECORD
+BRANCH 
+classname=java2.util2.BitSet,methodname=nextClearBit,line=653,id=66,direction=false
+SEQUENCE
+var0 =  cons : java2.util2.BitSet.<init>() : 
+var1 =  prim : int:0 : 
+var2 =  method : java2.util2.BitSet.flip(int) : var0 var1 
+var3 =  prim : int:0 : 
+var4 =  method : java2.util2.BitSet.nextClearBit(int) : var0 var3 
+
+END RECORD
+
+As source code:
+java2.util2.BitSet var0 = new java2.util2.BitSet();
+java.lang.Integer var1 = new java.lang.Integer((int)0);
+var0.flip((int)var1);
+java.lang.Integer var3 = new java.lang.Integer((int)0);
+int var4 = var0.nextClearBit((int)var3);
+
+Variables: [var3:[0], var1:[0]]
+      /**
+       * Returns the index of the first bit that is set to <code>false</code>
+       * that occurs on or after the specified starting index.
+       * 
+       * @param   fromIndex the index to start checking from (inclusive).
+       * @return  the index of the next clear bit.
+       * @throws  IndexOutOfBoundsException if the specified index is negative.
+       * @since   1.4
+       */
+      public int nextClearBit(int fromIndex) {
+  	if (fromIndex < 0)
+  	    throw new IndexOutOfBoundsException("fromIndex < 0: " + fromIndex);
+  
+          int u = unitIndex(fromIndex);
+          if (u >= unitsInUse)
+              return fromIndex;
+          int testIndex = (fromIndex & BIT_INDEX_MASK);
+          long unit = bits[u] >> testIndex;
+  
+          if (unit == (WORD_MASK >> testIndex))
+              testIndex = 0;
+  
+          while((unit==WORD_MASK) && (u < unitsInUse-1))
+              unit = bits[++u];
+  
+>>        if (unit == WORD_MASK)
+              return length();
+          
+          if (unit == 0)
+              return u * BITS_PER_UNIT + testIndex;
+  
+          testIndex += trailingZeroCnt(~unit);
+          return ((u * BITS_PER_UNIT) + testIndex);
+      }
+
+
+WILL TRY TO REPLACE var3 WITH var1
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=nextClearBit,line=653,id=66,direction=true
+WILL TRY REPLACING var3 WITH VALUE 0
+WILL TRY NEGATING var3
+WILL TRY SETTING TO ZERO var3
+WILL TRY ADDING 1 var3
+WILL TRY SUBTRACTING 1 var3
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=nextClearBit,line=653,id=66,direction=true
+WILL TRY REPLACING var1 WITH VALUE 0
+WILL TRY NEGATING var1
+WILL TRY SETTING TO ZERO var1
+WILL TRY ADDING 1 var1
+WILL TRY SUBTRACTING 1 var1
+FAILURE
+============================================================
+
+
+    // TODO
+
+START RECORD
+BRANCH 
+classname=java2.util2.BitSet,methodname=trailingZeroCnt,line=587,id=58,direction=false
+SEQUENCE
+var0 =  cons : java2.util2.BitSet.<init>() : 
+var1 =  prim : int:10 : 
+var2 =  method : java2.util2.BitSet.flip(int) : var0 var1 
+var3 =  prim : int:0 : 
+var4 =  prim : int:10 : 
+var5 =  method : java2.util2.BitSet.flip(int,int) : var0 var3 var4 
+var6 =  prim : int:0 : 
+var7 =  method : java2.util2.BitSet.clear(int) : var0 var6 
+var8 =  prim : int:0 : 
+var9 =  prim : int:10 : 
+var10 =  method : java2.util2.BitSet.get(int,int) : var0 var8 var9 
+var11 =  prim : int:0 : 
+var12 =  prim : int:100 : 
+var13 =  method : java2.util2.BitSet.flip(int,int) : var10 var11 var12 
+var14 =  prim : int:10 : 
+var15 =  method : java2.util2.BitSet.nextClearBit(int) : var10 var14 
+
+END RECORD
+
+As source code:
+java2.util2.BitSet var0 = new java2.util2.BitSet();
+java.lang.Integer var1 = new java.lang.Integer((int)10);
+var0.flip((int)var1);
+java.lang.Integer var3 = new java.lang.Integer((int)0);
+java.lang.Integer var4 = new java.lang.Integer((int)10);
+var0.flip((int)var3, (int)var4);
+java.lang.Integer var6 = new java.lang.Integer((int)0);
+var0.clear((int)var6);
+java.lang.Integer var8 = new java.lang.Integer((int)0);
+java.lang.Integer var9 = new java.lang.Integer((int)10);
+java2.util2.BitSet var10 = var0.get((int)var8, (int)var9);
+java.lang.Integer var11 = new java.lang.Integer((int)0);
+java.lang.Integer var12 = new java.lang.Integer((int)100);
+var10.flip((int)var11, (int)var12);
+java.lang.Integer var14 = new java.lang.Integer((int)10);
+int var15 = var10.nextClearBit((int)var14);
+
+Variables: [var12:[0], var14:[0]]
+      private static int trailingZeroCnt(long val) {
+          // Loop unrolled for performance
+          int byteVal = (int)val & 0xff;
+          if (byteVal != 0)
+              return trailingZeroTable[byteVal];
+  
+          byteVal = (int)(val >>> 8) & 0xff;
+          if (byteVal != 0)
+              return trailingZeroTable[byteVal] + 8;
+  
+          byteVal = (int)(val >>> 16) & 0xff;
+          if (byteVal != 0)
+              return trailingZeroTable[byteVal] + 16;
+  
+          byteVal = (int)(val >>> 24) & 0xff;
+>>        if (byteVal != 0)
+              return trailingZeroTable[byteVal] + 24;
+  
+          byteVal = (int)(val >>> 32) & 0xff;
+          if (byteVal != 0)
+              return trailingZeroTable[byteVal] + 32;
+  
+          byteVal = (int)(val >>> 40) & 0xff;
+          if (byteVal != 0)
+              return trailingZeroTable[byteVal] + 40;
+  
+          byteVal = (int)(val >>> 48) & 0xff;
+          if (byteVal != 0)
+              return trailingZeroTable[byteVal] + 48;
+  
+          byteVal = (int)(val >>> 56) & 0xff;
+          return trailingZeroTable[byteVal] + 56;
+      }
+
+
+WILL TRY TO REPLACE var14 WITH var12
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=trailingZeroCnt,line=587,id=58,direction=true
+WILL TRY REPLACING var12 WITH VALUE 0
+WILL TRY NEGATING var12
+WILL TRY SETTING TO ZERO var12
+WILL TRY ADDING 1 var12
+WILL TRY SUBTRACTING 1 var12
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=trailingZeroCnt,line=587,id=58,direction=true
+WILL TRY REPLACING var14 WITH VALUE 0
+WILL TRY NEGATING var14
+WILL TRY SETTING TO ZERO var14
+WILL TRY ADDING 1 var14
+WILL TRY SUBTRACTING 1 var14
+FAILURE
+============================================================
+
+    // TODO
+
+START RECORD
+BRANCH 
+classname=java2.util2.BitSet,methodname=trailingZeroCnt,line=591,id=59,direction=true
+SEQUENCE
+var0 =  cons : java2.util2.BitSet.<init>() : 
+var1 =  prim : int:10 : 
+var2 =  method : java2.util2.BitSet.flip(int) : var0 var1 
+var3 =  prim : int:0 : 
+var4 =  prim : int:10 : 
+var5 =  method : java2.util2.BitSet.flip(int,int) : var0 var3 var4 
+var6 =  prim : int:0 : 
+var7 =  method : java2.util2.BitSet.clear(int) : var0 var6 
+var8 =  prim : int:0 : 
+var9 =  prim : int:10 : 
+var10 =  method : java2.util2.BitSet.get(int,int) : var0 var8 var9 
+var11 =  prim : int:0 : 
+var12 =  prim : int:100 : 
+var13 =  method : java2.util2.BitSet.flip(int,int) : var10 var11 var12 
+var14 =  prim : int:10 : 
+var15 =  method : java2.util2.BitSet.nextClearBit(int) : var10 var14 
+
+END RECORD
+
+As source code:
+java2.util2.BitSet var0 = new java2.util2.BitSet();
+java.lang.Integer var1 = new java.lang.Integer((int)10);
+var0.flip((int)var1);
+java.lang.Integer var3 = new java.lang.Integer((int)0);
+java.lang.Integer var4 = new java.lang.Integer((int)10);
+var0.flip((int)var3, (int)var4);
+java.lang.Integer var6 = new java.lang.Integer((int)0);
+var0.clear((int)var6);
+java.lang.Integer var8 = new java.lang.Integer((int)0);
+java.lang.Integer var9 = new java.lang.Integer((int)10);
+java2.util2.BitSet var10 = var0.get((int)var8, (int)var9);
+java.lang.Integer var11 = new java.lang.Integer((int)0);
+java.lang.Integer var12 = new java.lang.Integer((int)100);
+var10.flip((int)var11, (int)var12);
+java.lang.Integer var14 = new java.lang.Integer((int)10);
+int var15 = var10.nextClearBit((int)var14);
+
+Variables: [var12:[0], var14:[0]]
+      private static int trailingZeroCnt(long val) {
+          // Loop unrolled for performance
+          int byteVal = (int)val & 0xff;
+          if (byteVal != 0)
+              return trailingZeroTable[byteVal];
+  
+          byteVal = (int)(val >>> 8) & 0xff;
+          if (byteVal != 0)
+              return trailingZeroTable[byteVal] + 8;
+  
+          byteVal = (int)(val >>> 16) & 0xff;
+          if (byteVal != 0)
+              return trailingZeroTable[byteVal] + 16;
+  
+          byteVal = (int)(val >>> 24) & 0xff;
+          if (byteVal != 0)
+              return trailingZeroTable[byteVal] + 24;
+  
+          byteVal = (int)(val >>> 32) & 0xff;
+>>        if (byteVal != 0)
+              return trailingZeroTable[byteVal] + 32;
+  
+          byteVal = (int)(val >>> 40) & 0xff;
+          if (byteVal != 0)
+              return trailingZeroTable[byteVal] + 40;
+  
+          byteVal = (int)(val >>> 48) & 0xff;
+          if (byteVal != 0)
+              return trailingZeroTable[byteVal] + 48;
+  
+          byteVal = (int)(val >>> 56) & 0xff;
+          return trailingZeroTable[byteVal] + 56;
+      }
+
+
+WILL TRY TO REPLACE var14 WITH var12
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=trailingZeroCnt,line=591,id=59,direction=false
+WILL TRY REPLACING var12 WITH VALUE 0
+WILL TRY NEGATING var12
+WILL TRY SETTING TO ZERO var12
+WILL TRY ADDING 1 var12
+WILL TRY SUBTRACTING 1 var12
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=trailingZeroCnt,line=591,id=59,direction=false
+WILL TRY REPLACING var14 WITH VALUE 0
+WILL TRY NEGATING var14
+WILL TRY SETTING TO ZERO var14
+WILL TRY ADDING 1 var14
+WILL TRY SUBTRACTING 1 var14
+FAILURE
+============================================================
+
+    // This seq will never get us past the branch. Need to try another
+    // one. Should be pretty easy to reach.
+
+START RECORD
+BRANCH 
+classname=java2.util2.AbstractList,methodname=listIterator,line=388,id=11,direction=false
+SEQUENCE
+var0 =  prim : long:-1 : 
+var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
+var2 =  method : java2.util2.Collections.sort(java2.util2.List) : var1 
+
+END RECORD
+
+As source code:
+java.lang.Long var0 = new java.lang.Long((long)-1);
+java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
+java2.util2.Collections.sort((java2.util2.List)var1);
+
+Variables: [var0:[0]]
+      /**
+       * Returns a list iterator of the elements in this list (in proper
+       * sequence), starting at the specified position in the list.  The
+       * specified index indicates the first element that would be returned by
+       * an initial call to the <tt>next</tt> method.  An initial call to
+       * the <tt>previous</tt> method would return the element with the
+       * specified index minus one.<p>
+       *
+       * This implementation returns a straightforward implementation of the
+       * <tt>ListIterator</tt> interface that extends the implementation of the
+       * <tt>Iterator</tt> interface returned by the <tt>iterator()</tt> method.
+       * The <tt>ListIterator</tt> implementation relies on the backing list's
+       * <tt>get(int)</tt>, <tt>set(int, Object)</tt>, <tt>add(int, Object)</tt>
+       * and <tt>remove(int)</tt> methods.<p>
+       *
+       * Note that the list iterator returned by this implementation will throw
+       * an <tt>UnsupportedOperationException</tt> in response to its
+       * <tt>remove</tt>, <tt>set</tt> and <tt>add</tt> methods unless the
+       * list's <tt>remove(int)</tt>, <tt>set(int, Object)</tt>, and
+       * <tt>add(int, Object)</tt> methods are overridden.<p>
+       *
+       * This implementation can be made to throw runtime exceptions in the
+       * face of concurrent modification, as described in the specification for
+       * the (protected) <tt>modCount</tt> field.
+       *
+       * @param index index of the first element to be returned from the list
+       *		    iterator (by a call to the <tt>next</tt> method).
+       * 
+       * @return a list iterator of the elements in this list (in proper
+       * 	       sequence), starting at the specified position in the list.
+       * 
+       * @throws IndexOutOfBoundsException if the specified index is out of
+       *		  range (<tt>index &lt; 0 || index &gt; size()</tt>).
+       * 
+       * @see #modCount
+       */
+      public ListIterator listIterator(final int index) {
+>>	if (index<0 || index>size())
+  	  throw new IndexOutOfBoundsException("Index: "+index);
+  
+  	return new ListItr(index);
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractList,methodname=listIterator,line=388,id=11,direction=true
+FAILURE
+============================================================
+
+    // Covered by (1) replicating var14 (call the replica z), and (2)
+    // replacing var3 occurrences with z.
+
+    // DF says var3 is interesting. var14 is interesting because it is
+    // in the method call that reaches the frontier branch.
+
+// START RECORD
+// BRANCH 
+// classname=java2.util2.AbstractMap,methodname=equals,line=505,id=25,direction=false
+// SEQUENCE
+
+// x =  prim : java.lang.Object:null : 
+// y =  prim : double:0.0 : 
+// z =  method : java2.util2.Collections.singletonMap(java.lang.Object,java.lang.Object) : x y
+
+// var0 =  prim : int:100 : 
+// var1 =  prim : short:10 : 
+// var2 =  method : java2.util2.Collections.singleton(java.lang.Object) : var1 
+// var3 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var2 
+// var4 =  method : java2.util2.Collections.nCopies(int,java.lang.Object) : var0 z
+// var5 =  prim : long:1 : 
+// var6 =  prim : java.lang.Object:null : 
+// var7 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var4 var5 var6 
+// var8 =  method : java2.util2.Collections.enumeration(java2.util2.Collection) : var4 
+// var9 =  prim : char:34 : 
+// var10 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var9 
+// var11 =  method : java2.util2.Collections.lastIndexOfSubList(java2.util2.List,java2.util2.List) : var4 var10 
+// var12 =  prim : java.lang.Object:null : 
+// var13 =  prim : double:0.0 : 
+// var14 =  method : java2.util2.Collections.singletonMap(java.lang.Object,java.lang.Object) : var12 var13 
+// var15 =  prim : java.lang.Object:null : 
+// var16 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var4 var14 var15 
+
+// END RECORD
+
+
+START RECORD
+BRANCH 
+classname=java2.util2.AbstractMap,methodname=equals,line=505,id=25,direction=true
+SEQUENCE
+var0 =  prim : int:100 : 
+var1 =  prim : short:10 : 
+var2 =  method : java2.util2.Collections.singleton(java.lang.Object) : var1 
+var3 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var2 
+var4 =  method : java2.util2.Collections.nCopies(int,java.lang.Object) : var0 var3 
+var5 =  prim : long:1 : 
+var6 =  prim : java.lang.Object:null : 
+var7 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var4 var5 var6 
+var8 =  method : java2.util2.Collections.enumeration(java2.util2.Collection) : var4 
+var9 =  prim : char:34 : 
+var10 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var9 
+var11 =  method : java2.util2.Collections.lastIndexOfSubList(java2.util2.List,java2.util2.List) : var4 var10 
+var12 =  prim : java.lang.Object:null : 
+var13 =  prim : double:0.0 : 
+var14 =  method : java2.util2.Collections.singletonMap(java.lang.Object,java.lang.Object) : var12 var13 
+var15 =  prim : java.lang.Object:null : 
+var16 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var4 var14 var15 
+
+END RECORD
+
+As source code:
+java.lang.Integer var0 = new java.lang.Integer((int)100);
+java.lang.Short var1 = new java.lang.Short((short)10);
+java2.util2.Set var2 = java2.util2.Collections.singleton((java.lang.Object)var1);
+java2.util2.Collection var3 = java2.util2.Collections.unmodifiableCollection((java2.util2.Collection)var2);
+java2.util2.List var4 = java2.util2.Collections.nCopies((int)var0, (java.lang.Object)var3);
+java.lang.Long var5 = new java.lang.Long((long)1);
+java.lang.Object var6 = null;
+boolean var7 = java2.util2.Collections.replaceAll((java2.util2.List)var4, (java.lang.Object)var5, (java.lang.Object)var6);
+java2.util2.Enumeration var8 = java2.util2.Collections.enumeration((java2.util2.Collection)var4);
+java.lang.Character var9 = new java.lang.Character((char)'4');
+java2.util2.List var10 = java2.util2.Collections.singletonList((java.lang.Object)var9);
+int var11 = java2.util2.Collections.lastIndexOfSubList((java2.util2.List)var4, (java2.util2.List)var10);
+java.lang.Object var12 = null;
+java.lang.Double var13 = new java.lang.Double((double)0.0);
+java2.util2.Map var14 = java2.util2.Collections.singletonMap((java.lang.Object)var12, (java.lang.Object)var13);
+java.lang.Object var15 = null;
+boolean var16 = java2.util2.Collections.replaceAll((java2.util2.List)var4, (java.lang.Object)var14, (java.lang.Object)var15);
+
+Variables: [var3:[0]]
+      /**
+       * Compares the specified object with this map for equality.  Returns
+       * <tt>true</tt> if the given object is also a map and the two maps
+       * represent the same mappings.  More formally, two maps <tt>t1</tt> and
+       * <tt>t2</tt> represent the same mappings if
+       * <tt>t1.keySet().equals(t2.keySet())</tt> and for every key <tt>k</tt>
+       * in <tt>t1.keySet()</tt>, <tt> (t1.get(k)==null ? t2.get(k)==null :
+       * t1.get(k).equals(t2.get(k))) </tt>.  This ensures that the
+       * <tt>equals</tt> method works properly across different implementations
+       * of the map interface.<p>
+       *
+       * This implementation first checks if the specified object is this map;
+       * if so it returns <tt>true</tt>.  Then, it checks if the specified
+       * object is a map whose size is identical to the size of this set; if
+       * not, it it returns <tt>false</tt>.  If so, it iterates over this map's
+       * <tt>entrySet</tt> collection, and checks that the specified map
+       * contains each mapping that this map contains.  If the specified map
+       * fails to contain such a mapping, <tt>false</tt> is returned.  If the
+       * iteration completes, <tt>true</tt> is returned.
+       *
+       * @param o object to be compared for equality with this map.
+       * @return <tt>true</tt> if the specified object is equal to this map.
+       */
+      public boolean equals(Object o) {
+  	if (o == this)
+  	    return true;
+  
+>>	if (!(o instanceof Map))
+  	    return false;
+  	Map t = (Map) o;
+  	if (t.size() != size())
+  	    return false;
+  
+          try {
+              Iterator i = entrySet().iterator();
+              while (i.hasNext()) {
+                  Entry e = (Entry) i.next();
+                  Object key = e.getKey();
+                  Object value = e.getValue();
+                  if (value == null) {
+                      if (!(t.get(key)==null && t.containsKey(key)))
+                          return false;
+                  } else {
+                      if (!value.equals(t.get(key)))
+                          return false;
+                  }
+              }
+          } catch(ClassCastException unused)   {
+              return false;
+          } catch(NullPointerException unused) {
+              return false;
+          }
+  
+  	return true;
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractMap,methodname=equals,line=505,id=25,direction=false
+FAILURE
+============================================================
+
+    // Covered if (1) replicate var11 -> varb, (2) replace uses of var3 with varb.
+    // var11 is is interesting because it's in method that executes frontier branch.
+
+// START RECORD
+// BRANCH 
+// classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=false
+// SEQUENCE
+
+// var10 =  prim : short:10 : 
+// var11 =  method : java2.util2.Collections.singleton(java.lang.Object) : var10 
+
+// vara =  prim : short:10 : 
+// varb =  method : java2.util2.Collections.singleton(java.lang.Object) : vara
+
+// var0 =  prim : int:100 : 
+// var1 =  prim : short:10 : 
+// var2 =  method : java2.util2.Collections.singleton(java.lang.Object) : var1 
+// var3 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var2 
+// var4 =  method : java2.util2.Collections.nCopies(int,java.lang.Object) : var0 varb
+// var5 =  prim : long:1 : 
+// var6 =  prim : java.lang.Object:null : 
+// var7 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var4 var5 var6 
+// var8 =  method : java2.util2.Collections.enumeration(java2.util2.Collection) : var4 
+// var9 =  prim : java.lang.Object:null : 
+
+
+// var12 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var11 
+// var13 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var11 
+// var14 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var11 
+// var15 =  method : java2.util2.Collections.singletonMap(java.lang.Object,java.lang.Object) : var9 var11 
+// var16 =  prim : java.lang.Object:null : 
+// var17 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var4 var11 var16 
+
+// END RECORD
+
+START RECORD
+BRANCH 
+classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=true
+SEQUENCE
+var0 =  prim : int:100 : 
+var1 =  prim : short:10 : 
+var2 =  method : java2.util2.Collections.singleton(java.lang.Object) : var1 
+var3 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var2 
+var4 =  method : java2.util2.Collections.nCopies(int,java.lang.Object) : var0 var3 
+var5 =  prim : long:1 : 
+var6 =  prim : java.lang.Object:null : 
+var7 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var4 var5 var6 
+var8 =  method : java2.util2.Collections.enumeration(java2.util2.Collection) : var4 
+var9 =  prim : java.lang.Object:null : 
+var10 =  prim : short:10 : 
+var11 =  method : java2.util2.Collections.singleton(java.lang.Object) : var10 
+var12 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var11 
+var13 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var11 
+var14 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var11 
+var15 =  method : java2.util2.Collections.singletonMap(java.lang.Object,java.lang.Object) : var9 var11 
+var16 =  prim : java.lang.Object:null : 
+var17 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var4 var11 var16 
+
+END RECORD
+
+As source code:
+java.lang.Integer var0 = new java.lang.Integer((int)100);
+java.lang.Short var1 = new java.lang.Short((short)10);
+java2.util2.Set var2 = java2.util2.Collections.singleton((java.lang.Object)var1);
+java2.util2.Collection var3 = java2.util2.Collections.unmodifiableCollection((java2.util2.Collection)var2);
+java2.util2.List var4 = java2.util2.Collections.nCopies((int)var0, (java.lang.Object)var3);
+java.lang.Long var5 = new java.lang.Long((long)1);
+java.lang.Object var6 = null;
+boolean var7 = java2.util2.Collections.replaceAll((java2.util2.List)var4, (java.lang.Object)var5, (java.lang.Object)var6);
+java2.util2.Enumeration var8 = java2.util2.Collections.enumeration((java2.util2.Collection)var4);
+java.lang.Object var9 = null;
+java.lang.Short var10 = new java.lang.Short((short)10);
+java2.util2.Set var11 = java2.util2.Collections.singleton((java.lang.Object)var10);
+java2.util2.Collection var12 = java2.util2.Collections.unmodifiableCollection((java2.util2.Collection)var11);
+java2.util2.Collection var13 = java2.util2.Collections.unmodifiableCollection((java2.util2.Collection)var11);
+java2.util2.Collection var14 = java2.util2.Collections.unmodifiableCollection((java2.util2.Collection)var11);
+java2.util2.Map var15 = java2.util2.Collections.singletonMap((java.lang.Object)var9, (java.lang.Object)var11);
+java.lang.Object var16 = null;
+boolean var17 = java2.util2.Collections.replaceAll((java2.util2.List)var4, (java.lang.Object)var11, (java.lang.Object)var16);
+
+Variables: [var3:[0]]
+      /**
+       * Compares the specified object with this set for equality.  Returns
+       * <tt>true</tt> if the given object is also a set, the two sets have
+       * the same size, and every member of the given set is contained in
+       * this set.  This ensures that the <tt>equals</tt> method works
+       * properly across different implementations of the <tt>Set</tt>
+       * interface.<p>
+       *
+       * This implementation first checks if the specified object is this
+       * set; if so it returns <tt>true</tt>.  Then, it checks if the
+       * specified object is a set whose size is identical to the size of
+       * this set; if not, it it returns false.  If so, it returns
+       * <tt>containsAll((Collection) o)</tt>.
+       *
+       * @param o Object to be compared for equality with this set.
+       * @return <tt>true</tt> if the specified object is equal to this set.
+       */
+      public boolean equals(Object o) {
+  	if (o == this)
+  	    return true;
+  
+>>	if (!(o instanceof Set))
+  	    return false;
+  	Collection c = (Collection) o;
+  	if (c.size() != size())
+  	    return false;
+          try {
+              return containsAll(c);
+          } catch(ClassCastException unused)   {
+              return false;
+          } catch(NullPointerException unused) {
+              return false;
+          }
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=false
+FAILURE
+============================================================
+
+    // There's no way this sequence will work, because we need to
+    // increase the lists's size. And even if we get a mutable list,
+    // we need to increase it by >5000 elements... Not an easy one...
+
+START RECORD
+BRANCH 
+classname=java2.util2.Collections,methodname=binarySearch,line=197,id=2,direction=true
+SEQUENCE
+var0 =  prim : char:34 : 
+var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
+var2 =  prim : java.lang.Object:null : 
+var3 =  method : java2.util2.Collections.binarySearch(java2.util2.List,java.lang.Object) : var1 var2 
+
+END RECORD
+
+As source code:
+java.lang.Character var0 = new java.lang.Character((char)'4');
+java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
+java.lang.Object var2 = null;
+int var3 = java2.util2.Collections.binarySearch((java2.util2.List)var1, (java.lang.Object)var2);
+
+Variables: [var1:[0]]
+      /**
+       * Searches the specified list for the specified object using the binary
+       * search algorithm.  The list must be sorted into ascending order
+       * according to the <i>natural ordering</i> of its elements (as by the
+       * <tt>sort(List)</tt> method, above) prior to making this call.  If it is
+       * not sorted, the results are undefined.  If the list contains multiple
+       * elements equal to the specified object, there is no guarantee which one
+       * will be found.<p>
+       *
+       * This method runs in log(n) time for a "random access" list (which
+       * provides near-constant-time positional access).  If the specified list
+       * does not implement the {@link RandomAccess} and is large, this method
+       * will do an iterator-based binary search that performs O(n) link
+       * traversals and O(log n) element comparisons.
+       *
+       * @param  list the list to be searched.
+       * @param  key the key to be searched for.
+       * @return index of the search key, if it is contained in the list;
+       *	       otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
+       *	       <i>insertion point</i> is defined as the point at which the
+       *	       key would be inserted into the list: the index of the first
+       *	       element greater than the key, or <tt>list.size()</tt>, if all
+       *	       elements in the list are less than the specified key.  Note
+       *	       that this guarantees that the return value will be &gt;= 0 if
+       *	       and only if the key is found.
+       * @throws ClassCastException if the list contains elements that are not
+       *	       <i>mutually comparable</i> (for example, strings and
+       *	       integers), or the search key in not mutually comparable
+       *	       with the elements of the list.
+       * @see    Comparable
+       * @see #sort(List)
+       */
+      public static int binarySearch(List list, Object key) {
+>>        if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)
+              return indexedBinarySearch(list, key);
+          else
+              return iteratorBinarySearch(list, key);
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Collections,methodname=binarySearch,line=197,id=2,direction=false
+FAILURE
+============================================================
+
+    // Same as above.
+
+START RECORD
+BRANCH 
+classname=java2.util2.Collections,methodname=binarySearch,line=300,id=11,direction=true
+SEQUENCE
+var0 =  prim : double:10.0 : 
+var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
+var2 =  prim : java.lang.Object:null : 
+var3 =  method : java2.util2.Collections.reverseOrder() : 
+var4 =  method : java2.util2.Collections.binarySearch(java2.util2.List,java.lang.Object,java2.util2.Comparator) : var1 var2 var3 
+
+END RECORD
+
+As source code:
+java.lang.Double var0 = new java.lang.Double((double)10.0);
+java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
+java.lang.Object var2 = null;
+java2.util2.Comparator var3 = java2.util2.Collections.reverseOrder();
+int var4 = java2.util2.Collections.binarySearch((java2.util2.List)var1, (java.lang.Object)var2, (java2.util2.Comparator)var3);
+
+Variables: [var1:[0]]
+      /**
+       * Searches the specified list for the specified object using the binary
+       * search algorithm.  The list must be sorted into ascending order
+       * according to the specified comparator (as by the <tt>Sort(List,
+       * Comparator)</tt> method, above), prior to making this call.  If it is
+       * not sorted, the results are undefined.  If the list contains multiple
+       * elements equal to the specified object, there is no guarantee which one
+       * will be found.<p>
+       *
+       * This method runs in log(n) time for a "random access" list (which
+       * provides near-constant-time positional access).  If the specified list
+       * does not implement the {@link RandomAccess} and is large, this
+       * this method will do an iterator-based binary search that performs
+       * O(n) link traversals and O(log n) element comparisons.
+       *
+       * @param  list the list to be searched.
+       * @param  key the key to be searched for.
+       * @param  c the comparator by which the list is ordered.  A
+       *        <tt>null</tt> value indicates that the elements' <i>natural
+       *        ordering</i> should be used.
+       * @return index of the search key, if it is contained in the list;
+       *	       otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
+       *	       <i>insertion point</i> is defined as the point at which the
+       *	       key would be inserted into the list: the index of the first
+       *	       element greater than the key, or <tt>list.size()</tt>, if all
+       *	       elements in the list are less than the specified key.  Note
+       *	       that this guarantees that the return value will be &gt;= 0 if
+       *	       and only if the key is found.
+       * @throws ClassCastException if the list contains elements that are not
+       *	       <i>mutually comparable</i> using the specified comparator,
+       *	       or the search key in not mutually comparable with the
+       *	       elements of the list using this comparator.
+       * @see    Comparable
+       * @see #sort(List, Comparator)
+       */
+      public static int binarySearch(List list, Object key, Comparator c) {
+          if (c==null)
+              return binarySearch(list, key);
+  
+>>        if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)
+              return indexedBinarySearch(list, key, c);
+          else
+              return iteratorBinarySearch(list, key, c);
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Collections,methodname=binarySearch,line=300,id=11,direction=false
+FAILURE
+============================================================
+
+    // Works if replace uses of var0 with var2. Requires moving var2 decl up.
+
+// START RECORD
+// BRANCH 
+// classname=java2.util2.Collections,methodname=replaceAll,line=804,id=56,direction=true
+// SEQUENCE
+// var2 =  prim : char:20 : 
+
+// var0 =  prim : java.lang.Object:null : 
+// var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var2
+
+// var3 =  prim : java.lang.Object:null : 
+// var4 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var1 var2 var3 
+
+// END RECORD
+
+
+START RECORD
+BRANCH 
+classname=java2.util2.Collections,methodname=replaceAll,line=804,id=56,direction=false
+SEQUENCE
+var0 =  prim : java.lang.Object:null : 
+var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
+var2 =  prim : char:20 : 
+var3 =  prim : java.lang.Object:null : 
+var4 =  method : java2.util2.Collections.replaceAll(java2.util2.List,java.lang.Object,java.lang.Object) : var1 var2 var3 
+
+END RECORD
+
+As source code:
+java.lang.Object var0 = null;
+java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
+java.lang.Character var2 = new java.lang.Character((char)' ');
+java.lang.Object var3 = null;
+boolean var4 = java2.util2.Collections.replaceAll((java2.util2.List)var1, (java.lang.Object)var2, (java.lang.Object)var3);
+
+Variables: [var0:[0], var3:[0]]
+      /**
+       * Replaces all occurrences of one specified value in a list with another.
+       * More formally, replaces with <tt>newVal</tt> each element <tt>e</tt>
+       * in <tt>list</tt> such that
+       * <tt>(oldVal==null ? e==null : oldVal.equals(e))</tt>.
+       * (This method has no effect on the size of the list.)
+       *
+       * @param list the list in which replacement is to occur.
+       * @param oldVal the old value to be replaced.
+       * @param newVal the new value with which <tt>oldVal</tt> is to be
+       *        replaced.
+       * @return <tt>true</tt> if <tt>list</tt> contained one or more elements
+       *         <tt>e</tt> such that
+       *         <tt>(oldVal==null ?  e==null : oldVal.equals(e))</tt>.
+       * @throws UnsupportedOperationException if the specified list or
+       *         its list-iterator does not support the <tt>set</tt> method.
+       * @since  1.4
+       */
+      public static boolean replaceAll(List list, Object oldVal, Object newVal) {
+          boolean result = false;
+          int size = list.size();
+          if (size < REPLACEALL_THRESHOLD || list instanceof RandomAccess) {
+              if (oldVal==null) {
+                  for (int i=0; i<size; i++) {
+                      if (list.get(i)==null) {
+                          list.set(i, newVal);
+                          result = true;
+                      }
+                  }
+              } else {
+                  for (int i=0; i<size; i++) {
+>>                    if (oldVal.equals(list.get(i))) {
+                          list.set(i, newVal);
+                          result = true;
+                      }
+                  }
+              }
+          } else {
+              ListIterator itr=list.listIterator();
+              if (oldVal==null) {
+                  for (int i=0; i<size; i++) {
+                      if (itr.next()==null) {
+                          itr.set(newVal);
+                          result = true;
+                      }
+                  }
+              } else {
+                  for (int i=0; i<size; i++) {
+                      if (oldVal.equals(itr.next())) {
+                          itr.set(newVal);
+                          result = true;
+                      }
+                  }
+              }
+          }
+          return result;
+      }
+
+
+WILL TRY TO REPLACE var3 WITH var0
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Collections,methodname=replaceAll,line=804,id=56,direction=true
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Collections,methodname=replaceAll,line=804,id=56,direction=true
+FAILURE
+============================================================
+
+    // Would need to create a very large list.
+
+START RECORD
+BRANCH 
+classname=java2.util2.Collections,methodname=rotate,line=729,id=42,direction=true
+SEQUENCE
+var0 =  prim : long:-1 : 
+var1 =  method : java2.util2.Collections.singletonList(java.lang.Object) : var0 
+var2 =  prim : int:10 : 
+var3 =  method : java2.util2.Collections.rotate(java2.util2.List,int) : var1 var2 
+
+END RECORD
+
+As source code:
+java.lang.Long var0 = new java.lang.Long((long)-1);
+java2.util2.List var1 = java2.util2.Collections.singletonList((java.lang.Object)var0);
+java.lang.Integer var2 = new java.lang.Integer((int)10);
+java2.util2.Collections.rotate((java2.util2.List)var1, (int)var2);
+
+Variables: [var1:[0]]
+      /**
+       * Rotates the elements in the specified list by the specified distance.
+       * After calling this method, the element at index <tt>i</tt> will be
+       * the element previously at index <tt>(i - distance)</tt> mod
+       * <tt>list.size()</tt>, for all values of <tt>i</tt> between <tt>0</tt>
+       * and <tt>list.size()-1</tt>, inclusive.  (This method has no effect on
+       * the size of the list.)
+       *
+       * <p>For example, suppose <tt>list</tt> comprises<tt> [t, a, n, k, s]</tt>.
+       * After invoking <tt>Collections.rotate(list, 1)</tt> (or
+       * <tt>Collections.rotate(list, -4)</tt>), <tt>list</tt> will comprise
+       * <tt>[s, t, a, n, k]</tt>.
+       *
+       * <p>Note that this method can usefully be applied to sublists to
+       * move one or more elements within a list while preserving the
+       * order of the remaining elements.  For example, the following idiom
+       * moves the element at index <tt>j</tt> forward to position
+       * <tt>k</tt> (which must be greater than or equal to <tt>j</tt>):
+       * <pre>
+       *     Collections.rotate(list.subList(j, k+1), -1);
+       * </pre>
+       * To make this concrete, suppose <tt>list</tt> comprises
+       * <tt>[a, b, c, d, e]</tt>.  To move the element at index <tt>1</tt>
+       * (<tt>b</tt>) forward two positions, perform the following invocation:
+       * <pre>
+       *     Collections.rotate(l.subList(1, 4), -1);
+       * </pre>
+       * The resulting list is <tt>[a, c, d, b, e]</tt>.
+       * 
+       * <p>To move more than one element forward, increase the absolute value
+       * of the rotation distance.  To move elements backward, use a positive
+       * shift distance.
+       *
+       * <p>If the specified list is small or implements the {@link
+       * RandomAccess} interface, this implementation exchanges the first
+       * element into the location it should go, and then repeatedly exchanges
+       * the displaced element into the location it should go until a displaced
+       * element is swapped into the first element.  If necessary, the process
+       * is repeated on the second and successive elements, until the rotation
+       * is complete.  If the specified list is large and doesn't implement the
+       * <tt>RandomAccess</tt> interface, this implementation breaks the
+       * list into two sublist views around index <tt>-distance mod size</tt>.
+       * Then the {@link #reverse(List)} method is invoked on each sublist view,
+       * and finally it is invoked on the entire list.  For a more complete
+       * description of both algorithms, see Section 2.3 of Jon Bentley's
+       * <i>Programming Pearls</i> (Addison-Wesley, 1986).
+       *
+       * @param list the list to be rotated.
+       * @param distance the distance to rotate the list.  There are no
+       *        constraints on this value; it may be zero, negative, or
+       *        greater than <tt>list.size()</tt>.
+       * @throws UnsupportedOperationException if the specified list or
+       *         its list-iterator does not support the <tt>set</tt> method.
+       * @since 1.4
+       */
+      public static void rotate(List list, int distance) {
+>>        if (list instanceof RandomAccess || list.size() < ROTATE_THRESHOLD)
+              rotate1(list, distance);
+          else
+              rotate2(list, distance);
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Collections,methodname=rotate,line=729,id=42,direction=false
+FAILURE
+============================================================
+
+    // Not gonna work. Totate gets passed an NCopies list that is not
+    // modifiable, so an exception is thrown and we never reach the
+    // desired branch direction.
+
+START RECORD
+BRANCH 
+classname=java2.util2.Collections,methodname=rotate1,line=745,id=46,direction=true
+SEQUENCE
+var0 =  prim : int:100 : 
+var1 =  prim : short:10 : 
+var2 =  method : java2.util2.Collections.singleton(java.lang.Object) : var1 
+var3 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var2 
+var4 =  method : java2.util2.Collections.nCopies(int,java.lang.Object) : var0 var3 
+var5 =  method : java2.util2.Collections.synchronizedList(java2.util2.List) : var4 
+var6 =  prim : int:1 : 
+var7 =  method : java2.util2.Collections.rotate(java2.util2.List,int) : var5 var6 
+
+END RECORD
+
+As source code:
+java.lang.Integer var0 = new java.lang.Integer((int)100);
+java.lang.Short var1 = new java.lang.Short((short)10);
+java2.util2.Set var2 = java2.util2.Collections.singleton((java.lang.Object)var1);
+java2.util2.Collection var3 = java2.util2.Collections.unmodifiableCollection((java2.util2.Collection)var2);
+java2.util2.List var4 = java2.util2.Collections.nCopies((int)var0, (java.lang.Object)var3);
+java2.util2.List var5 = java2.util2.Collections.synchronizedList((java2.util2.List)var4);
+java.lang.Integer var6 = new java.lang.Integer((int)1);
+java2.util2.Collections.rotate((java2.util2.List)var5, (int)var6);
+
+Variables: [var0:[100]]
+      private static void rotate1(List list, int distance) {
+          int size = list.size();
+          if (size == 0)
+              return;
+          distance = distance % size;
+          if (distance < 0)
+              distance += size;
+          if (distance == 0)
+              return;
+  
+>>        for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) {
+              Object displaced = list.get(cycleStart);
+              int i = cycleStart;
+              do {
+                  i += distance;
+                  if (i >= size)
+                      i -= size;
+                  displaced = list.set(i, displaced);
+                  nMoved ++;
+              } while(i != cycleStart);
+          }
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Collections,methodname=rotate1,line=745,id=46,direction=false
+WILL TRY REPLACING var0 WITH VALUE 100
+WILL TRY NEGATING var0
+WILL TRY SETTING TO ZERO var0
+WILL TRY ADDING 1 var0
+WILL TRY SUBTRACTING 1 var0
+FAILURE
+============================================================
+
+    // Not gonna work. Totate gets passed an NCopies list that is not
+    // modifiable, so an exception is thrown and we never reach the
+    // desired branch direction.
+
+START RECORD
+BRANCH 
+classname=java2.util2.Collections,methodname=rotate1,line=750,id=47,direction=false
+SEQUENCE
+var0 =  prim : int:100 : 
+var1 =  prim : short:10 : 
+var2 =  method : java2.util2.Collections.singleton(java.lang.Object) : var1 
+var3 =  method : java2.util2.Collections.unmodifiableCollection(java2.util2.Collection) : var2 
+var4 =  method : java2.util2.Collections.nCopies(int,java.lang.Object) : var0 var3 
+var5 =  method : java2.util2.Collections.synchronizedList(java2.util2.List) : var4 
+var6 =  prim : int:1 : 
+var7 =  method : java2.util2.Collections.rotate(java2.util2.List,int) : var5 var6 
+
+END RECORD
+
+As source code:
+java.lang.Integer var0 = new java.lang.Integer((int)100);
+java.lang.Short var1 = new java.lang.Short((short)10);
+java2.util2.Set var2 = java2.util2.Collections.singleton((java.lang.Object)var1);
+java2.util2.Collection var3 = java2.util2.Collections.unmodifiableCollection((java2.util2.Collection)var2);
+java2.util2.List var4 = java2.util2.Collections.nCopies((int)var0, (java.lang.Object)var3);
+java2.util2.List var5 = java2.util2.Collections.synchronizedList((java2.util2.List)var4);
+java.lang.Integer var6 = new java.lang.Integer((int)1);
+java2.util2.Collections.rotate((java2.util2.List)var5, (int)var6);
+
+Variables: [var0:[1, 100], var6:[1]]
+      private static void rotate1(List list, int distance) {
+          int size = list.size();
+          if (size == 0)
+              return;
+          distance = distance % size;
+          if (distance < 0)
+              distance += size;
+          if (distance == 0)
+              return;
+  
+          for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) {
+              Object displaced = list.get(cycleStart);
+              int i = cycleStart;
+              do {
+                  i += distance;
+>>                if (i >= size)
+                      i -= size;
+                  displaced = list.set(i, displaced);
+                  nMoved ++;
+              } while(i != cycleStart);
+          }
+      }
+
+
+WILL TRY TO REPLACE var6 WITH var0
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Collections,methodname=rotate1,line=750,id=47,direction=true
+WILL TRY REPLACING var0 WITH VALUE 1
+WILL TRY REPLACING var0 WITH VALUE 100
+WILL TRY NEGATING var0
+WILL TRY SETTING TO ZERO var0
+WILL TRY ADDING 1 var0
+WILL TRY SUBTRACTING 1 var0
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Collections,methodname=rotate1,line=750,id=47,direction=true
+WILL TRY REPLACING var6 WITH VALUE 1
+WILL TRY NEGATING var6
+WILL TRY SETTING TO ZERO var6
+WILL TRY ADDING 1 var6
+WILL TRY SUBTRACTING 1 var6
+FAILURE
+============================================================
+
+    // Not gonna work because shuffle always calls nextInt with legal
+    // input.
+
+START RECORD
+BRANCH 
+classname=java2.util2.Random,methodname=nextInt,line=250,id=3,direction=false
+SEQUENCE
+var0 =  prim : int:100 : 
+var1 =  prim : java.lang.Object:null : 
+var2 =  method : java2.util2.Collections.nCopies(int,java.lang.Object) : var0 var1 
+var3 =  method : java2.util2.Collections.shuffle(java2.util2.List) : var2 
+
+END RECORD
+
+As source code:
+java.lang.Integer var0 = new java.lang.Integer((int)100);
+java.lang.Object var1 = null;
+java2.util2.List var2 = java2.util2.Collections.nCopies((int)var0, (java.lang.Object)var1);
+java2.util2.Collections.shuffle((java2.util2.List)var2);
+
+Variables: [var0:[0]]
+      /**
+       * Returns a pseudorandom, uniformly distributed <tt>int</tt> value
+       * between 0 (inclusive) and the specified value (exclusive), drawn from
+       * this random number generator's sequence.  The general contract of
+       * <tt>nextInt</tt> is that one <tt>int</tt> value in the specified range
+       * is pseudorandomly generated and returned.  All <tt>n</tt> possible
+       * <tt>int</tt> values are produced with (approximately) equal
+       * probability.  The method <tt>nextInt(int n)</tt> is implemented by
+       * class <tt>Random</tt> as follows:
+       * <blockquote><pre>
+       * public int nextInt(int n) {
+       *     if (n<=0)
+       *		throw new IllegalArgumentException("n must be positive");
+       *
+       *     if ((n & -n) == n)  // i.e., n is a power of 2
+       *         return (int)((n * (long)next(31)) >> 31);
+       *
+       *     int bits, val;
+       *     do {
+       *         bits = next(31);
+       *         val = bits % n;
+       *     } while(bits - val + (n-1) < 0);
+       *     return val;
+       * }
+       * </pre></blockquote>
+       * <p>
+       * The hedge "approximately" is used in the foregoing description only 
+       * because the next method is only approximately an unbiased source of
+       * independently chosen bits.  If it were a perfect source of randomly 
+       * chosen bits, then the algorithm shown would choose <tt>int</tt> 
+       * values from the stated range with perfect uniformity.
+       * <p>
+       * The algorithm is slightly tricky.  It rejects values that would result
+       * in an uneven distribution (due to the fact that 2^31 is not divisible
+       * by n). The probability of a value being rejected depends on n.  The
+       * worst case is n=2^30+1, for which the probability of a reject is 1/2,
+       * and the expected number of iterations before the loop terminates is 2.
+       * <p>
+       * The algorithm treats the case where n is a power of two specially: it
+       * returns the correct number of high-order bits from the underlying
+       * pseudo-random number generator.  In the absence of special treatment,
+       * the correct number of <i>low-order</i> bits would be returned.  Linear
+       * congruential pseudo-random number generators such as the one
+       * implemented by this class are known to have short periods in the
+       * sequence of values of their low-order bits.  Thus, this special case
+       * greatly increases the length of the sequence of values returned by
+       * successive calls to this method if n is a small power of two.
+       *
+       * @param n the bound on the random number to be returned.  Must be
+       *	      positive.
+       * @return  a pseudorandom, uniformly distributed <tt>int</tt>
+       *          value between 0 (inclusive) and n (exclusive).
+       * @exception IllegalArgumentException n is not positive.
+       * @since 1.2
+       */
+  
+      public int nextInt(int n) {
+>>        if (n<=0)
+              throw new IllegalArgumentException("n must be positive");
+  
+          if ((n & -n) == n)  // i.e., n is a power of 2
+              return (int)((n * (long)next(31)) >> 31);
+  
+          int bits, val;
+          do {
+              bits = next(31);
+              val = bits % n;
+          } while(bits - val + (n-1) < 0);
+          return val;
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Random,methodname=nextInt,line=250,id=3,direction=true
+WILL TRY REPLACING var0 WITH VALUE 0
+WILL TRY NEGATING var0
+WILL TRY SETTING TO ZERO var0
+WILL TRY ADDING 1 var0
+WILL TRY SUBTRACTING 1 var0
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=false
+SEQUENCE
+var0 =  cons : java2.util2.HashMap.<init>() : 
+var1 =  prim : double:-1.0 : 
+var2 =  prim : java.lang.String:"hi!" : 
+var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  prim : java.lang.Object:null : 
+var5 =  cons : java2.util2.HashMap.<init>() : 
+var6 =  method : java2.util2.HashMap.values() : var5 
+var7 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var6 
+var8 =  method : java2.util2.AbstractMap.toString() : var0 
+var9 =  prim : java.lang.String:"" : 
+var10 =  method : java2.util2.HashMap.get(java.lang.Object) : var0 var9 
+var11 =  cons : java2.util2.HashMap.<init>() : 
+var12 =  prim : double:-1.0 : 
+var13 =  prim : java.lang.String:"hi!" : 
+var14 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var11 var12 var13 
+var15 =  prim : java.lang.Object:null : 
+var16 =  cons : java2.util2.HashMap.<init>() : 
+var17 =  method : java2.util2.HashMap.values() : var16 
+var18 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var11 var15 var17 
+var19 =  method : java2.util2.AbstractMap.toString() : var11 
+var20 =  prim : java.lang.Object:null : 
+var21 =  method : java2.util2.HashMap.get(java.lang.Object) : var11 var20 
+var22 =  method : java2.util2.HashMap.size() : var11 
+var23 =  prim : long:-1 : 
+var24 =  method : java2.util2.HashMap.containsValue(java.lang.Object) : var11 var23 
+var25 =  method : java2.util2.HashMap.keySet() : var11 
+var26 =  method : java2.util2.HashMap.containsValue(java.lang.Object) : var0 var25 
+
+END RECORD
+
+As source code:
+java2.util2.HashMap var0 = new java2.util2.HashMap();
+java.lang.Double var1 = new java.lang.Double((double)-1.0);
+java.lang.String var2 = "hi!";
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java.lang.Object var4 = null;
+java2.util2.HashMap var5 = new java2.util2.HashMap();
+java2.util2.Collection var6 = var5.values();
+java.lang.Object var7 = var0.put((java.lang.Object)var4, (java.lang.Object)var6);
+java.lang.String var8 = var0.toString();
+java.lang.String var9 = "";
+java.lang.Object var10 = var0.get((java.lang.Object)var9);
+java2.util2.HashMap var11 = new java2.util2.HashMap();
+java.lang.Double var12 = new java.lang.Double((double)-1.0);
+java.lang.String var13 = "hi!";
+java.lang.Object var14 = var11.put((java.lang.Object)var12, (java.lang.Object)var13);
+java.lang.Object var15 = null;
+java2.util2.HashMap var16 = new java2.util2.HashMap();
+java2.util2.Collection var17 = var16.values();
+java.lang.Object var18 = var11.put((java.lang.Object)var15, (java.lang.Object)var17);
+java.lang.String var19 = var11.toString();
+java.lang.Object var20 = null;
+java.lang.Object var21 = var11.get((java.lang.Object)var20);
+int var22 = var11.size();
+java.lang.Long var23 = new java.lang.Long((long)-1);
+boolean var24 = var11.containsValue((java.lang.Object)var23);
+java2.util2.Set var25 = var11.keySet();
+boolean var26 = var0.containsValue((java.lang.Object)var25);
+
+Variables: [var13:[object], var25:[object], var6:[object]]
+      /**
+       * Compares the specified object with this set for equality.  Returns
+       * <tt>true</tt> if the given object is also a set, the two sets have
+       * the same size, and every member of the given set is contained in
+       * this set.  This ensures that the <tt>equals</tt> method works
+       * properly across different implementations of the <tt>Set</tt>
+       * interface.<p>
+       *
+       * This implementation first checks if the specified object is this
+       * set; if so it returns <tt>true</tt>.  Then, it checks if the
+       * specified object is a set whose size is identical to the size of
+       * this set; if not, it it returns false.  If so, it returns
+       * <tt>containsAll((Collection) o)</tt>.
+       *
+       * @param o Object to be compared for equality with this set.
+       * @return <tt>true</tt> if the specified object is equal to this set.
+       */
+      public boolean equals(Object o) {
+>>	if (o == this)
+  	    return true;
+  
+  	if (!(o instanceof Set))
+  	    return false;
+  	Collection c = (Collection) o;
+  	if (c.size() != size())
+  	    return false;
+          try {
+              return containsAll(c);
+          } catch(ClassCastException unused)   {
+              return false;
+          } catch(NullPointerException unused) {
+              return false;
+          }
+      }
+
+
+WILL TRY TO REPLACE var13 WITH var6
+WILL TRY TO REPLACE var25 WITH var6
+WILL TRY TO REPLACE var25 WITH var13
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=true
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=true
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=true
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=true
+SEQUENCE
+var0 =  cons : java2.util2.HashMap.<init>() : 
+var1 =  prim : double:-1.0 : 
+var2 =  prim : java.lang.String:"hi!" : 
+var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  prim : java.lang.Object:null : 
+var5 =  cons : java2.util2.HashMap.<init>() : 
+var6 =  method : java2.util2.HashMap.values() : var5 
+var7 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var6 
+var8 =  method : java2.util2.AbstractMap.toString() : var0 
+var9 =  prim : java.lang.String:"" : 
+var10 =  method : java2.util2.HashMap.get(java.lang.Object) : var0 var9 
+var11 =  cons : java2.util2.HashMap.<init>() : 
+var12 =  prim : double:-1.0 : 
+var13 =  prim : java.lang.String:"hi!" : 
+var14 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var11 var12 var13 
+var15 =  prim : java.lang.Object:null : 
+var16 =  cons : java2.util2.HashMap.<init>() : 
+var17 =  method : java2.util2.HashMap.values() : var16 
+var18 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var11 var15 var17 
+var19 =  method : java2.util2.AbstractMap.toString() : var11 
+var20 =  prim : java.lang.Object:null : 
+var21 =  method : java2.util2.HashMap.get(java.lang.Object) : var11 var20 
+var22 =  method : java2.util2.HashMap.size() : var11 
+var23 =  prim : long:-1 : 
+var24 =  method : java2.util2.HashMap.containsValue(java.lang.Object) : var11 var23 
+var25 =  method : java2.util2.HashMap.keySet() : var11 
+var26 =  method : java2.util2.HashMap.containsValue(java.lang.Object) : var0 var25 
+
+END RECORD
+
+As source code:
+java2.util2.HashMap var0 = new java2.util2.HashMap();
+java.lang.Double var1 = new java.lang.Double((double)-1.0);
+java.lang.String var2 = "hi!";
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java.lang.Object var4 = null;
+java2.util2.HashMap var5 = new java2.util2.HashMap();
+java2.util2.Collection var6 = var5.values();
+java.lang.Object var7 = var0.put((java.lang.Object)var4, (java.lang.Object)var6);
+java.lang.String var8 = var0.toString();
+java.lang.String var9 = "";
+java.lang.Object var10 = var0.get((java.lang.Object)var9);
+java2.util2.HashMap var11 = new java2.util2.HashMap();
+java.lang.Double var12 = new java.lang.Double((double)-1.0);
+java.lang.String var13 = "hi!";
+java.lang.Object var14 = var11.put((java.lang.Object)var12, (java.lang.Object)var13);
+java.lang.Object var15 = null;
+java2.util2.HashMap var16 = new java2.util2.HashMap();
+java2.util2.Collection var17 = var16.values();
+java.lang.Object var18 = var11.put((java.lang.Object)var15, (java.lang.Object)var17);
+java.lang.String var19 = var11.toString();
+java.lang.Object var20 = null;
+java.lang.Object var21 = var11.get((java.lang.Object)var20);
+int var22 = var11.size();
+java.lang.Long var23 = new java.lang.Long((long)-1);
+boolean var24 = var11.containsValue((java.lang.Object)var23);
+java2.util2.Set var25 = var11.keySet();
+boolean var26 = var0.containsValue((java.lang.Object)var25);
+
+Variables: [var13:[0], var6:[0]]
+      /**
+       * Compares the specified object with this set for equality.  Returns
+       * <tt>true</tt> if the given object is also a set, the two sets have
+       * the same size, and every member of the given set is contained in
+       * this set.  This ensures that the <tt>equals</tt> method works
+       * properly across different implementations of the <tt>Set</tt>
+       * interface.<p>
+       *
+       * This implementation first checks if the specified object is this
+       * set; if so it returns <tt>true</tt>.  Then, it checks if the
+       * specified object is a set whose size is identical to the size of
+       * this set; if not, it it returns false.  If so, it returns
+       * <tt>containsAll((Collection) o)</tt>.
+       *
+       * @param o Object to be compared for equality with this set.
+       * @return <tt>true</tt> if the specified object is equal to this set.
+       */
+      public boolean equals(Object o) {
+  	if (o == this)
+  	    return true;
+  
+>>	if (!(o instanceof Set))
+  	    return false;
+  	Collection c = (Collection) o;
+  	if (c.size() != size())
+  	    return false;
+          try {
+              return containsAll(c);
+          } catch(ClassCastException unused)   {
+              return false;
+          } catch(NullPointerException unused) {
+              return false;
+          }
+      }
+
+
+WILL TRY TO REPLACE var13 WITH var6
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=false
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=false
+FAILURE
+============================================================
+
+START RECORD
+BRANCH 
+classname=java2.util2.HashMap,methodname=containsValue,line=621,id=34,direction=false
+SEQUENCE
+var0 =  cons : java2.util2.HashMap.<init>() : 
+var1 =  prim : java.lang.Object:null : 
+var2 =  prim : java.lang.Object:null : 
+var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  prim : char:20 : 
+var5 =  method : java2.util2.HashMap.containsValue(java.lang.Object) : var0 var4 
+
+END RECORD
+
+As source code:
+java2.util2.HashMap var0 = new java2.util2.HashMap();
+java.lang.Object var1 = null;
+java.lang.Object var2 = null;
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java.lang.Character var4 = new java.lang.Character((char)' ');
+boolean var5 = var0.containsValue((java.lang.Object)var4);
+
+Variables: [var2:[0], var3:[0], var1:[0]]
+      /**
+       * Returns <tt>true</tt> if this map maps one or more keys to the
+       * specified value.
+       *
+       * @param value value whose presence in this map is to be tested.
+       * @return <tt>true</tt> if this map maps one or more keys to the
+       *         specified value.
+       */
+      public boolean containsValue(Object value) {
+  	if (value == null) 
+              return containsNullValue();
+  
+  	Entry tab[] = table;
+          for (int i = 0; i < tab.length ; i++)
+              for (Entry e = tab[i] ; e != null ; e = e.next)
+>>                if (value.equals(e.value))
+                      return true;
+  	return false;
+      }
+
+
+WILL TRY TO REPLACE var2 WITH var1
+WILL TRY TO REPLACE var3 WITH var1
+WILL TRY TO REPLACE var3 WITH var2
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.HashMap,methodname=containsValue,line=621,id=34,direction=true
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.HashMap,methodname=containsValue,line=621,id=34,direction=true
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.HashMap,methodname=containsValue,line=621,id=34,direction=true
+FAILURE
+============================================================
+
+    // We'll need another sequence. Hashtables do not allow null
+    // values, but we need a map that allows a null value.
+
+START RECORD
+BRANCH 
+classname=java2.util2.Hashtable,methodname=equals,line=733,id=34,direction=false
+SEQUENCE
+var0 =  cons : java2.util2.Hashtable.<init>() : 
+var1 =  prim : long:10 : 
+var2 =  prim : short:0 : 
+var3 =  method : java2.util2.Hashtable.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  cons : java2.util2.Hashtable.<init>() : 
+var5 =  prim : long:10 : 
+var6 =  prim : short:0 : 
+var7 =  method : java2.util2.Hashtable.put(java.lang.Object,java.lang.Object) : var4 var5 var6 
+var8 =  method : java2.util2.Hashtable.values() : var4 
+var9 =  method : java2.util2.Hashtable.equals(java.lang.Object) : var0 var4 
+
+END RECORD
+
+As source code:
+java2.util2.Hashtable var0 = new java2.util2.Hashtable();
+java.lang.Long var1 = new java.lang.Long((long)10);
+java.lang.Short var2 = new java.lang.Short((short)0);
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java2.util2.Hashtable var4 = new java2.util2.Hashtable();
+java.lang.Long var5 = new java.lang.Long((long)10);
+java.lang.Short var6 = new java.lang.Short((short)0);
+java.lang.Object var7 = var4.put((java.lang.Object)var5, (java.lang.Object)var6);
+java2.util2.Collection var8 = var4.values();
+boolean var9 = var0.equals((java.lang.Object)var4);
+
+Variables: [var6:[null]]
+      /**
+       * Compares the specified Object with this Map for equality,
+       * as per the definition in the Map interface.
+       *
+       * @param  o object to be compared for equality with this Hashtable
+       * @return true if the specified Object is equal to this Map.
+       * @see Map#equals(Object)
+       * @since 1.2
+       */
+      public synchronized boolean equals(Object o) {
+  	if (o == this)
+  	    return true;
+  
+  	if (!(o instanceof Map))
+  	    return false;
+  	Map t = (Map) o;
+  	if (t.size() != size())
+  	    return false;
+  
+          try {
+              Iterator i = entrySet().iterator();
+              while (i.hasNext()) {
+                  Map.Entry e = (Map.Entry) i.next();
+                  Object key = e.getKey();
+                  Object value = e.getValue();
+>>                if (value == null) {
+                      if (!(t.get(key)==null && t.containsKey(key)))
+                          return false;
+                  } else {
+                      if (!value.equals(t.get(key)))
+                          return false;
+                  }
+              }
+          } catch(ClassCastException unused)   {
+              return false;
+          } catch(NullPointerException unused) {
+              return false;
+          }
+  
+  	return true;
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Hashtable,methodname=equals,line=733,id=34,direction=true
+Primitive value...
+FAILURE
+
+============================================================
+
+    // need to make var1 a Map (but not an IdentityHashMap).
+    // If we knew about the branch (o instanceof Map), this
+    // could be arranged.
+
+START RECORD
+BRANCH 
+classname=java2.util2.IdentityHashMap,methodname=equals,line=629,id=36,direction=false
+SEQUENCE
+var0 =  cons : java2.util2.IdentityHashMap.<init>() : 
+var1 =  prim : float:100.0 : 
+var2 =  method : java2.util2.IdentityHashMap.equals(java.lang.Object) : var0 var1 
+
+END RECORD
+
+As source code:
+java2.util2.IdentityHashMap var0 = new java2.util2.IdentityHashMap();
+java.lang.Float var1 = new java.lang.Float((float)100.0);
+boolean var2 = var0.equals((java.lang.Object)var1);
+
+Variables: [var1:[0]]
+      /**
+       * Compares the specified object with this map for equality.  Returns
+       * <tt>true</tt> if the given object is also a map and the two maps
+       * represent identical object-reference mappings.  More formally, this
+       * map is equal to another map <tt>m</tt> if and only if
+       * map <tt>this.entrySet().equals(m.entrySet())</tt>.
+       *
+       * <p><b>Owing to the reference-equality-based semantics of this map it is
+       * possible that the symmetry and transitivity requirements of the
+       * <tt>Object.equals</tt> contract may be violated if this map is compared
+       * to a normal map.  However, the <tt>Object.equals</tt> contract is
+       * guaranteed to hold among <tt>IdentityHashMap</tt> instances.</b>
+       *
+       * @param  o object to be compared for equality with this map.
+       * @return <tt>true</tt> if the specified object is equal to this map.
+       * @see Object#equals(Object)
+       */
+      public boolean equals(Object o) {
+          if (o == this) {
+              return true;
+          } else if (o instanceof IdentityHashMap) {
+              IdentityHashMap m = (IdentityHashMap) o;
+              if (m.size() != size)
+                  return false;
+  
+              Object[] tab = m.table;
+              for (int i = 0; i < tab.length; i+=2) {
+                  Object k = tab[i];
+                  if (k != null && !containsMapping(k, tab[i + 1]))
+                      return false;
+              }
+              return true;
+>>        } else if (o instanceof Map) {
+              Map m = (Map)o;
+              return entrySet().equals(m.entrySet());
+          } else {
+              return false;  // o is not a Map
+          }
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.IdentityHashMap,methodname=equals,line=629,id=36,direction=true
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.IdentityHashMap,methodname=resize,line=455,id=19,direction=false
+SEQUENCE
+var0 =  cons : java2.util2.IdentityHashMap.<init>() : 
+var1 =  prim : java.lang.Object:null : 
+var2 =  prim : double:1.0 : 
+var3 =  method : java2.util2.IdentityHashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  prim : char:20 : 
+var5 =  cons : java2.util2.IdentityHashMap.<init>() : 
+var6 =  method : java2.util2.IdentityHashMap.keySet() : var5 
+var7 =  method : java2.util2.IdentityHashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var5 
+var8 =  cons : java2.util2.IdentityHashMap.<init>(java2.util2.Map) : var0 
+
+END RECORD
+
+As source code:
+java2.util2.IdentityHashMap var0 = new java2.util2.IdentityHashMap();
+java.lang.Object var1 = null;
+java.lang.Double var2 = new java.lang.Double((double)1.0);
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java.lang.Character var4 = new java.lang.Character((char)' ');
+java2.util2.IdentityHashMap var5 = new java2.util2.IdentityHashMap();
+java2.util2.Set var6 = var5.keySet();
+java.lang.Object var7 = var0.put((java.lang.Object)var4, (java.lang.Object)var5);
+java2.util2.IdentityHashMap var8 = new java2.util2.IdentityHashMap((java2.util2.Map)var0);
+
+Variables: [var7:[null], var1:[null], var3:[null]]
+      /**
+       * Resize the table to hold given capacity.
+       *
+       * @param newCapacity the new capacity, must be a power of two.
+       */
+      private void resize(int newCapacity) {
+          // assert (newCapacity & -newCapacity) == newCapacity; // power of 2
+          int newLength = newCapacity * 2; 
+  
+          Object[] oldTable = table;
+          int oldLength = oldTable.length;
+          if (oldLength == 2*MAXIMUM_CAPACITY) { // can't expand any further
+              if (threshold == MAXIMUM_CAPACITY-1)
+                  throw new IllegalStateException("Capacity exhausted.");
+              threshold = MAXIMUM_CAPACITY-1;  // Gigantic map!
+              return;
+          }
+          if (oldLength >= newLength)
+              return;
+  
+          Object[] newTable = new Object[newLength];
+          threshold = newLength / 3;
+  
+          for (int j = 0; j < oldLength; j += 2) {
+              Object key = oldTable[j];
+              if (key != null) {
+                  Object value = oldTable[j+1];
+                  oldTable[j] = null;
+                  oldTable[j+1] = null;
+                  int i = hash(key, newLength);
+>>                while (newTable[i] != null) 
+                      i = nextKeyIndex(i, newLength);
+                  newTable[i] = key;
+                  newTable[i + 1] = value;
+              }
+          }
+          table = newTable;
+      }
+
+
+WILL TRY TO REPLACE var3 WITH var1
+WILL TRY TO REPLACE var7 WITH var1
+WILL TRY TO REPLACE var7 WITH var3
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.IdentityHashMap,methodname=resize,line=455,id=19,direction=true
+REPLACING ALL USES OF var7 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.IdentityHashMap.<init>() : 
+var1 =  prim : java.lang.Object:null : 
+var2 =  prim : double:1.0 : 
+var3 =  method : java2.util2.IdentityHashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  prim : char:20 : 
+var5 =  cons : java2.util2.IdentityHashMap.<init>() : 
+var6 =  method : java2.util2.IdentityHashMap.keySet() : var5 
+var7 =  prim : java.lang.Object:null : 
+var8 =  method : java2.util2.IdentityHashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var5 
+var9 =  cons : java2.util2.IdentityHashMap.<init>(java2.util2.Map) : var0 
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.IdentityHashMap,methodname=resize,line=455,id=19,direction=true
+WILL USE:
+var0 =  prim : byte:-1 : 
+
+
+REPLACING ALL USES OF var1 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.IdentityHashMap.<init>() : 
+var1 =  prim : byte:-1 : 
+var2 =  prim : java.lang.Object:null : 
+var3 =  prim : double:1.0 : 
+var4 =  method : java2.util2.IdentityHashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var3 
+var5 =  prim : char:20 : 
+var6 =  cons : java2.util2.IdentityHashMap.<init>() : 
+var7 =  method : java2.util2.IdentityHashMap.keySet() : var6 
+var8 =  method : java2.util2.IdentityHashMap.put(java.lang.Object,java.lang.Object) : var0 var5 var6 
+var9 =  cons : java2.util2.IdentityHashMap.<init>(java2.util2.Map) : var0 
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.IdentityHashMap,methodname=resize,line=455,id=19,direction=true
+REPLACING ALL USES OF var3 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.IdentityHashMap.<init>() : 
+var1 =  prim : java.lang.Object:null : 
+var2 =  prim : double:1.0 : 
+var3 =  prim : java.lang.Object:null : 
+var4 =  method : java2.util2.IdentityHashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var5 =  prim : char:20 : 
+var6 =  cons : java2.util2.IdentityHashMap.<init>() : 
+var7 =  method : java2.util2.IdentityHashMap.keySet() : var6 
+var8 =  method : java2.util2.IdentityHashMap.put(java.lang.Object,java.lang.Object) : var0 var5 var6 
+var9 =  cons : java2.util2.IdentityHashMap.<init>(java2.util2.Map) : var0 
+
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.AbstractMap,methodname=equals,line=518,id=29,direction=true
+SEQUENCE
+var0 =  cons : java2.util2.LinkedHashMap.<init>() : 
+var1 =  prim : java.lang.Object:null : 
+var2 =  prim : double:-1.0 : 
+var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  prim : java.lang.Object:null : 
+var5 =  prim : java.lang.Object:null : 
+var6 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var5 
+var7 =  cons : java2.util2.LinkedHashMap.<init>() : 
+var8 =  prim : double:0.0 : 
+var9 =  prim : int:100 : 
+var10 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var7 var8 var9 
+var11 =  method : java2.util2.HashMap.entrySet() : var7 
+var12 =  method : java2.util2.AbstractMap.equals(java.lang.Object) : var0 var7 
+
+END RECORD
+
+As source code:
+java2.util2.LinkedHashMap var0 = new java2.util2.LinkedHashMap();
+java.lang.Object var1 = null;
+java.lang.Double var2 = new java.lang.Double((double)-1.0);
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java.lang.Object var4 = null;
+java.lang.Object var5 = null;
+java.lang.Object var6 = var0.put((java.lang.Object)var4, (java.lang.Object)var5);
+java2.util2.LinkedHashMap var7 = new java2.util2.LinkedHashMap();
+java.lang.Double var8 = new java.lang.Double((double)0.0);
+java.lang.Integer var9 = new java.lang.Integer((int)100);
+java.lang.Object var10 = var7.put((java.lang.Object)var8, (java.lang.Object)var9);
+java2.util2.Set var11 = var7.entrySet();
+boolean var12 = var0.equals((java.lang.Object)var7);
+
+Variables: [var1:[null], var3:[null], var5:[null], var4:[null], var10:[null]]
+      /**
+       * Compares the specified object with this map for equality.  Returns
+       * <tt>true</tt> if the given object is also a map and the two maps
+       * represent the same mappings.  More formally, two maps <tt>t1</tt> and
+       * <tt>t2</tt> represent the same mappings if
+       * <tt>t1.keySet().equals(t2.keySet())</tt> and for every key <tt>k</tt>
+       * in <tt>t1.keySet()</tt>, <tt> (t1.get(k)==null ? t2.get(k)==null :
+       * t1.get(k).equals(t2.get(k))) </tt>.  This ensures that the
+       * <tt>equals</tt> method works properly across different implementations
+       * of the map interface.<p>
+       *
+       * This implementation first checks if the specified object is this map;
+       * if so it returns <tt>true</tt>.  Then, it checks if the specified
+       * object is a map whose size is identical to the size of this set; if
+       * not, it it returns <tt>false</tt>.  If so, it iterates over this map's
+       * <tt>entrySet</tt> collection, and checks that the specified map
+       * contains each mapping that this map contains.  If the specified map
+       * fails to contain such a mapping, <tt>false</tt> is returned.  If the
+       * iteration completes, <tt>true</tt> is returned.
+       *
+       * @param o object to be compared for equality with this map.
+       * @return <tt>true</tt> if the specified object is equal to this map.
+       */
+      public boolean equals(Object o) {
+  	if (o == this)
+  	    return true;
+  
+  	if (!(o instanceof Map))
+  	    return false;
+  	Map t = (Map) o;
+  	if (t.size() != size())
+  	    return false;
+  
+          try {
+              Iterator i = entrySet().iterator();
+              while (i.hasNext()) {
+                  Entry e = (Entry) i.next();
+                  Object key = e.getKey();
+                  Object value = e.getValue();
+                  if (value == null) {
+>>                    if (!(t.get(key)==null && t.containsKey(key)))
+                          return false;
+                  } else {
+                      if (!value.equals(t.get(key)))
+                          return false;
+                  }
+              }
+          } catch(ClassCastException unused)   {
+              return false;
+          } catch(NullPointerException unused) {
+              return false;
+          }
+  
+  	return true;
+      }
+
+
+WILL TRY TO REPLACE var3 WITH var1
+WILL TRY TO REPLACE var4 WITH var1
+WILL TRY TO REPLACE var5 WITH var1
+WILL TRY TO REPLACE var10 WITH var1
+WILL TRY TO REPLACE var4 WITH var3
+WILL TRY TO REPLACE var5 WITH var3
+WILL TRY TO REPLACE var10 WITH var3
+WILL TRY TO REPLACE var5 WITH var4
+WILL TRY TO REPLACE var10 WITH var4
+WILL TRY TO REPLACE var10 WITH var5
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractMap,methodname=equals,line=518,id=29,direction=false
+WILL USE:
+var0 =  prim : byte:-1 : 
+
+
+REPLACING ALL USES OF var1 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.LinkedHashMap.<init>() : 
+var1 =  prim : byte:-1 : 
+var2 =  prim : java.lang.Object:null : 
+var3 =  prim : double:-1.0 : 
+var4 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var3 
+var5 =  prim : java.lang.Object:null : 
+var6 =  prim : java.lang.Object:null : 
+var7 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var5 var6 
+var8 =  cons : java2.util2.LinkedHashMap.<init>() : 
+var9 =  prim : double:0.0 : 
+var10 =  prim : int:100 : 
+var11 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var8 var9 var10 
+var12 =  method : java2.util2.HashMap.entrySet() : var8 
+var13 =  method : java2.util2.AbstractMap.equals(java.lang.Object) : var0 var8 
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractMap,methodname=equals,line=518,id=29,direction=false
+REPLACING ALL USES OF var3 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.LinkedHashMap.<init>() : 
+var1 =  prim : java.lang.Object:null : 
+var2 =  prim : double:-1.0 : 
+var3 =  prim : java.lang.Object:null : 
+var4 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var5 =  prim : java.lang.Object:null : 
+var6 =  prim : java.lang.Object:null : 
+var7 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var5 var6 
+var8 =  cons : java2.util2.LinkedHashMap.<init>() : 
+var9 =  prim : double:0.0 : 
+var10 =  prim : int:100 : 
+var11 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var8 var9 var10 
+var12 =  method : java2.util2.HashMap.entrySet() : var8 
+var13 =  method : java2.util2.AbstractMap.equals(java.lang.Object) : var0 var8 
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractMap,methodname=equals,line=518,id=29,direction=false
+WILL USE:
+var0 =  prim : byte:-1 : 
+
+
+REPLACING ALL USES OF var5 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.LinkedHashMap.<init>() : 
+var1 =  prim : java.lang.Object:null : 
+var2 =  prim : double:-1.0 : 
+var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  prim : java.lang.Object:null : 
+var5 =  prim : byte:-1 : 
+var6 =  prim : java.lang.Object:null : 
+var7 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var5 
+var8 =  cons : java2.util2.LinkedHashMap.<init>() : 
+var9 =  prim : double:0.0 : 
+var10 =  prim : int:100 : 
+var11 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var8 var9 var10 
+var12 =  method : java2.util2.HashMap.entrySet() : var8 
+var13 =  method : java2.util2.AbstractMap.equals(java.lang.Object) : var0 var8 
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractMap,methodname=equals,line=518,id=29,direction=false
+WILL USE:
+var0 =  prim : byte:-1 : 
+
+
+REPLACING ALL USES OF var4 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.LinkedHashMap.<init>() : 
+var1 =  prim : java.lang.Object:null : 
+var2 =  prim : double:-1.0 : 
+var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  prim : byte:-1 : 
+var5 =  prim : java.lang.Object:null : 
+var6 =  prim : java.lang.Object:null : 
+var7 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var6 
+var8 =  cons : java2.util2.LinkedHashMap.<init>() : 
+var9 =  prim : double:0.0 : 
+var10 =  prim : int:100 : 
+var11 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var8 var9 var10 
+var12 =  method : java2.util2.HashMap.entrySet() : var8 
+var13 =  method : java2.util2.AbstractMap.equals(java.lang.Object) : var0 var8 
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractMap,methodname=equals,line=518,id=29,direction=false
+REPLACING ALL USES OF var10 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.LinkedHashMap.<init>() : 
+var1 =  prim : java.lang.Object:null : 
+var2 =  prim : double:-1.0 : 
+var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  prim : java.lang.Object:null : 
+var5 =  prim : java.lang.Object:null : 
+var6 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var5 
+var7 =  cons : java2.util2.LinkedHashMap.<init>() : 
+var8 =  prim : double:0.0 : 
+var9 =  prim : int:100 : 
+var10 =  prim : java.lang.Object:null : 
+var11 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var7 var8 var9 
+var12 =  method : java2.util2.HashMap.entrySet() : var7 
+var13 =  method : java2.util2.AbstractMap.equals(java.lang.Object) : var0 var7 
+
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=false
+SEQUENCE
+var0 =  cons : java2.util2.LinkedHashMap.<init>() : 
+var1 =  prim : java.lang.Object:null : 
+var2 =  prim : double:0.0 : 
+var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  prim : int:10 : 
+var5 =  cons : java.lang.Object.<init>() : 
+var6 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var5 
+var7 =  method : java2.util2.HashMap.isEmpty() : var0 
+var8 =  prim : java.lang.Object:null : 
+var9 =  method : java2.util2.LinkedHashMap.get(java.lang.Object) : var0 var8 
+var10 =  cons : java2.util2.LinkedHashMap.<init>() : 
+var11 =  prim : java.lang.Object:null : 
+var12 =  prim : double:-1.0 : 
+var13 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var10 var11 var12 
+var14 =  prim : java.lang.Object:null : 
+var15 =  prim : java.lang.Object:null : 
+var16 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var10 var14 var15 
+var17 =  method : java2.util2.HashMap.keySet() : var10 
+var18 =  method : java2.util2.LinkedHashMap.containsValue(java.lang.Object) : var0 var17 
+
+END RECORD
+
+As source code:
+java2.util2.LinkedHashMap var0 = new java2.util2.LinkedHashMap();
+java.lang.Object var1 = null;
+java.lang.Double var2 = new java.lang.Double((double)0.0);
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java.lang.Integer var4 = new java.lang.Integer((int)10);
+java.lang.Object var5 = new java.lang.Object();
+java.lang.Object var6 = var0.put((java.lang.Object)var4, (java.lang.Object)var5);
+boolean var7 = var0.isEmpty();
+java.lang.Object var8 = null;
+java.lang.Object var9 = var0.get((java.lang.Object)var8);
+java2.util2.LinkedHashMap var10 = new java2.util2.LinkedHashMap();
+java.lang.Object var11 = null;
+java.lang.Double var12 = new java.lang.Double((double)-1.0);
+java.lang.Object var13 = var10.put((java.lang.Object)var11, (java.lang.Object)var12);
+java.lang.Object var14 = null;
+java.lang.Object var15 = null;
+java.lang.Object var16 = var10.put((java.lang.Object)var14, (java.lang.Object)var15);
+java2.util2.Set var17 = var10.keySet();
+boolean var18 = var0.containsValue((java.lang.Object)var17);
+
+Variables: [var9:[object], var2:[object], var17:[object], var5:[object]]
+      /**
+       * Compares the specified object with this set for equality.  Returns
+       * <tt>true</tt> if the given object is also a set, the two sets have
+       * the same size, and every member of the given set is contained in
+       * this set.  This ensures that the <tt>equals</tt> method works
+       * properly across different implementations of the <tt>Set</tt>
+       * interface.<p>
+       *
+       * This implementation first checks if the specified object is this
+       * set; if so it returns <tt>true</tt>.  Then, it checks if the
+       * specified object is a set whose size is identical to the size of
+       * this set; if not, it it returns false.  If so, it returns
+       * <tt>containsAll((Collection) o)</tt>.
+       *
+       * @param o Object to be compared for equality with this set.
+       * @return <tt>true</tt> if the specified object is equal to this set.
+       */
+      public boolean equals(Object o) {
+>>	if (o == this)
+  	    return true;
+  
+  	if (!(o instanceof Set))
+  	    return false;
+  	Collection c = (Collection) o;
+  	if (c.size() != size())
+  	    return false;
+          try {
+              return containsAll(c);
+          } catch(ClassCastException unused)   {
+              return false;
+          } catch(NullPointerException unused) {
+              return false;
+          }
+      }
+
+
+WILL TRY TO REPLACE var5 WITH var2
+WILL TRY TO REPLACE var9 WITH var2
+WILL TRY TO REPLACE var17 WITH var2
+WILL TRY TO REPLACE var9 WITH var5
+WILL TRY TO REPLACE var17 WITH var5
+WILL TRY TO REPLACE var17 WITH var9
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=true
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=true
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=true
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=66,id=0,direction=true
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=true
+SEQUENCE
+var0 =  cons : java2.util2.LinkedHashMap.<init>() : 
+var1 =  prim : java.lang.Object:null : 
+var2 =  prim : double:0.0 : 
+var3 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  prim : int:10 : 
+var5 =  cons : java.lang.Object.<init>() : 
+var6 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var0 var4 var5 
+var7 =  method : java2.util2.HashMap.isEmpty() : var0 
+var8 =  prim : java.lang.Object:null : 
+var9 =  method : java2.util2.LinkedHashMap.get(java.lang.Object) : var0 var8 
+var10 =  cons : java2.util2.LinkedHashMap.<init>() : 
+var11 =  prim : java.lang.Object:null : 
+var12 =  prim : double:-1.0 : 
+var13 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var10 var11 var12 
+var14 =  prim : java.lang.Object:null : 
+var15 =  prim : java.lang.Object:null : 
+var16 =  method : java2.util2.HashMap.put(java.lang.Object,java.lang.Object) : var10 var14 var15 
+var17 =  method : java2.util2.HashMap.keySet() : var10 
+var18 =  method : java2.util2.LinkedHashMap.containsValue(java.lang.Object) : var0 var17 
+
+END RECORD
+
+As source code:
+java2.util2.LinkedHashMap var0 = new java2.util2.LinkedHashMap();
+java.lang.Object var1 = null;
+java.lang.Double var2 = new java.lang.Double((double)0.0);
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java.lang.Integer var4 = new java.lang.Integer((int)10);
+java.lang.Object var5 = new java.lang.Object();
+java.lang.Object var6 = var0.put((java.lang.Object)var4, (java.lang.Object)var5);
+boolean var7 = var0.isEmpty();
+java.lang.Object var8 = null;
+java.lang.Object var9 = var0.get((java.lang.Object)var8);
+java2.util2.LinkedHashMap var10 = new java2.util2.LinkedHashMap();
+java.lang.Object var11 = null;
+java.lang.Double var12 = new java.lang.Double((double)-1.0);
+java.lang.Object var13 = var10.put((java.lang.Object)var11, (java.lang.Object)var12);
+java.lang.Object var14 = null;
+java.lang.Object var15 = null;
+java.lang.Object var16 = var10.put((java.lang.Object)var14, (java.lang.Object)var15);
+java2.util2.Set var17 = var10.keySet();
+boolean var18 = var0.containsValue((java.lang.Object)var17);
+
+Variables: [var9:[0], var2:[0], var5:[0]]
+      /**
+       * Compares the specified object with this set for equality.  Returns
+       * <tt>true</tt> if the given object is also a set, the two sets have
+       * the same size, and every member of the given set is contained in
+       * this set.  This ensures that the <tt>equals</tt> method works
+       * properly across different implementations of the <tt>Set</tt>
+       * interface.<p>
+       *
+       * This implementation first checks if the specified object is this
+       * set; if so it returns <tt>true</tt>.  Then, it checks if the
+       * specified object is a set whose size is identical to the size of
+       * this set; if not, it it returns false.  If so, it returns
+       * <tt>containsAll((Collection) o)</tt>.
+       *
+       * @param o Object to be compared for equality with this set.
+       * @return <tt>true</tt> if the specified object is equal to this set.
+       */
+      public boolean equals(Object o) {
+  	if (o == this)
+  	    return true;
+  
+>>	if (!(o instanceof Set))
+  	    return false;
+  	Collection c = (Collection) o;
+  	if (c.size() != size())
+  	    return false;
+          try {
+              return containsAll(c);
+          } catch(ClassCastException unused)   {
+              return false;
+          } catch(NullPointerException unused) {
+              return false;
+          }
+      }
+
+
+WILL TRY TO REPLACE var5 WITH var2
+WILL TRY TO REPLACE var9 WITH var2
+WILL TRY TO REPLACE var9 WITH var5
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=false
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=false
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractSet,methodname=equals,line=69,id=1,direction=false
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.SubList,methodname=listIterator,line=785,id=6,direction=false
+SEQUENCE
+var0 =  cons : java2.util2.LinkedList.<init>() : 
+var1 =  prim : double:1.0 : 
+var2 =  method : java2.util2.LinkedList.addFirst(java.lang.Object) : var0 var1 
+var3 =  prim : int:0 : 
+var4 =  cons : java2.util2.LinkedList.<init>() : 
+var5 =  prim : double:1.0 : 
+var6 =  method : java2.util2.LinkedList.addFirst(java.lang.Object) : var4 var5 
+var7 =  method : java2.util2.LinkedList.addAll(int,java2.util2.Collection) : var0 var3 var4 
+var8 =  prim : int:0 : 
+var9 =  prim : java.lang.Object:null : 
+var10 =  method : java2.util2.LinkedList.set(int,java.lang.Object) : var4 var8 var9 
+var11 =  cons : java2.util2.LinkedList.<init>() : 
+var12 =  method : java2.util2.AbstractSequentialList.iterator() : var11 
+var13 =  method : java2.util2.LinkedList.addLast(java.lang.Object) : var4 var12 
+var14 =  prim : java.lang.Object:null : 
+var15 =  method : java2.util2.LinkedList.contains(java.lang.Object) : var4 var14 
+var16 =  method : java2.util2.AbstractSequentialList.iterator() : var4 
+var17 =  cons : java2.util2.LinkedList.<init>(java2.util2.Collection) : var4 
+var18 =  method : java2.util2.AbstractCollection.isEmpty() : var4 
+var19 =  cons : java2.util2.LinkedList.<init>() : 
+var20 =  prim : double:1.0 : 
+var21 =  method : java2.util2.LinkedList.addFirst(java.lang.Object) : var19 var20 
+var22 =  prim : int:0 : 
+var23 =  cons : java2.util2.LinkedList.<init>() : 
+var24 =  prim : double:1.0 : 
+var25 =  method : java2.util2.LinkedList.addFirst(java.lang.Object) : var23 var24 
+var26 =  method : java2.util2.LinkedList.addAll(int,java2.util2.Collection) : var19 var22 var23 
+var27 =  prim : int:0 : 
+var28 =  prim : java.lang.Object:null : 
+var29 =  method : java2.util2.LinkedList.set(int,java.lang.Object) : var23 var27 var28 
+var30 =  prim : int:0 : 
+var31 =  cons : java.lang.Object.<init>() : 
+var32 =  method : java2.util2.LinkedList.add(int,java.lang.Object) : var23 var30 var31 
+var33 =  method : java2.util2.AbstractCollection.toString() : var23 
+var34 =  prim : java.lang.Object:null : 
+var35 =  method : java2.util2.LinkedList.addFirst(java.lang.Object) : var23 var34 
+var36 =  method : java2.util2.AbstractCollection.toString() : var23 
+var37 =  cons : java2.util2.LinkedList.<init>() : 
+var38 =  prim : double:1.0 : 
+var39 =  method : java2.util2.LinkedList.addFirst(java.lang.Object) : var37 var38 
+var40 =  prim : int:0 : 
+var41 =  cons : java2.util2.LinkedList.<init>() : 
+var42 =  prim : double:1.0 : 
+var43 =  method : java2.util2.LinkedList.addFirst(java.lang.Object) : var41 var42 
+var44 =  method : java2.util2.LinkedList.addAll(int,java2.util2.Collection) : var37 var40 var41 
+var45 =  prim : int:0 : 
+var46 =  prim : java.lang.Object:null : 
+var47 =  method : java2.util2.LinkedList.set(int,java.lang.Object) : var41 var45 var46 
+var48 =  prim : int:0 : 
+var49 =  method : java2.util2.LinkedList.listIterator(int) : var41 var48 
+var50 =  method : java2.util2.LinkedList.indexOf(java.lang.Object) : var23 var49 
+var51 =  prim : int:0 : 
+var52 =  prim : java.lang.Object:null : 
+var53 =  method : java2.util2.LinkedList.set(int,java.lang.Object) : var23 var51 var52 
+var54 =  method : java2.util2.LinkedList.addAll(java2.util2.Collection) : var4 var23 
+var55 =  cons : java2.util2.LinkedList.<init>() : 
+var56 =  prim : double:1.0 : 
+var57 =  method : java2.util2.LinkedList.addFirst(java.lang.Object) : var55 var56 
+var58 =  prim : int:0 : 
+var59 =  cons : java2.util2.LinkedList.<init>() : 
+var60 =  prim : double:1.0 : 
+var61 =  method : java2.util2.LinkedList.addFirst(java.lang.Object) : var59 var60 
+var62 =  method : java2.util2.LinkedList.addAll(int,java2.util2.Collection) : var55 var58 var59 
+var63 =  prim : int:0 : 
+var64 =  prim : java.lang.Object:null : 
+var65 =  method : java2.util2.LinkedList.set(int,java.lang.Object) : var59 var63 var64 
+var66 =  prim : int:0 : 
+var67 =  cons : java.lang.Object.<init>() : 
+var68 =  method : java2.util2.LinkedList.add(int,java.lang.Object) : var59 var66 var67 
+var69 =  method : java2.util2.AbstractCollection.toString() : var59 
+var70 =  prim : java.lang.Object:null : 
+var71 =  method : java2.util2.LinkedList.lastIndexOf(java.lang.Object) : var59 var70 
+var72 =  prim : int:0 : 
+var73 =  prim : int:0 : 
+var74 =  method : java2.util2.AbstractList.subList(int,int) : var59 var72 var73 
+var75 =  method : java2.util2.LinkedList.addAll(java2.util2.Collection) : var4 var74 
+
+END RECORD
+
+As source code:
+java2.util2.LinkedList var0 = new java2.util2.LinkedList();
+java.lang.Double var1 = new java.lang.Double((double)1.0);
+var0.addFirst((java.lang.Object)var1);
+java.lang.Integer var3 = new java.lang.Integer((int)0);
+java2.util2.LinkedList var4 = new java2.util2.LinkedList();
+java.lang.Double var5 = new java.lang.Double((double)1.0);
+var4.addFirst((java.lang.Object)var5);
+boolean var7 = var0.addAll((int)var3, (java2.util2.Collection)var4);
+java.lang.Integer var8 = new java.lang.Integer((int)0);
+java.lang.Object var9 = null;
+java.lang.Object var10 = var4.set((int)var8, (java.lang.Object)var9);
+java2.util2.LinkedList var11 = new java2.util2.LinkedList();
+java2.util2.Iterator var12 = var11.iterator();
+var4.addLast((java.lang.Object)var12);
+java.lang.Object var14 = null;
+boolean var15 = var4.contains((java.lang.Object)var14);
+java2.util2.Iterator var16 = var4.iterator();
+java2.util2.LinkedList var17 = new java2.util2.LinkedList((java2.util2.Collection)var4);
+boolean var18 = var4.isEmpty();
+java2.util2.LinkedList var19 = new java2.util2.LinkedList();
+java.lang.Double var20 = new java.lang.Double((double)1.0);
+var19.addFirst((java.lang.Object)var20);
+java.lang.Integer var22 = new java.lang.Integer((int)0);
+java2.util2.LinkedList var23 = new java2.util2.LinkedList();
+java.lang.Double var24 = new java.lang.Double((double)1.0);
+var23.addFirst((java.lang.Object)var24);
+boolean var26 = var19.addAll((int)var22, (java2.util2.Collection)var23);
+java.lang.Integer var27 = new java.lang.Integer((int)0);
+java.lang.Object var28 = null;
+java.lang.Object var29 = var23.set((int)var27, (java.lang.Object)var28);
+java.lang.Integer var30 = new java.lang.Integer((int)0);
+java.lang.Object var31 = new java.lang.Object();
+var23.add((int)var30, (java.lang.Object)var31);
+java.lang.String var33 = var23.toString();
+java.lang.Object var34 = null;
+var23.addFirst((java.lang.Object)var34);
+java.lang.String var36 = var23.toString();
+java2.util2.LinkedList var37 = new java2.util2.LinkedList();
+java.lang.Double var38 = new java.lang.Double((double)1.0);
+var37.addFirst((java.lang.Object)var38);
+java.lang.Integer var40 = new java.lang.Integer((int)0);
+java2.util2.LinkedList var41 = new java2.util2.LinkedList();
+java.lang.Double var42 = new java.lang.Double((double)1.0);
+var41.addFirst((java.lang.Object)var42);
+boolean var44 = var37.addAll((int)var40, (java2.util2.Collection)var41);
+java.lang.Integer var45 = new java.lang.Integer((int)0);
+java.lang.Object var46 = null;
+java.lang.Object var47 = var41.set((int)var45, (java.lang.Object)var46);
+java.lang.Integer var48 = new java.lang.Integer((int)0);
+java2.util2.ListIterator var49 = var41.listIterator((int)var48);
+int var50 = var23.indexOf((java.lang.Object)var49);
+java.lang.Integer var51 = new java.lang.Integer((int)0);
+java.lang.Object var52 = null;
+java.lang.Object var53 = var23.set((int)var51, (java.lang.Object)var52);
+boolean var54 = var4.addAll((java2.util2.Collection)var23);
+java2.util2.LinkedList var55 = new java2.util2.LinkedList();
+java.lang.Double var56 = new java.lang.Double((double)1.0);
+var55.addFirst((java.lang.Object)var56);
+java.lang.Integer var58 = new java.lang.Integer((int)0);
+java2.util2.LinkedList var59 = new java2.util2.LinkedList();
+java.lang.Double var60 = new java.lang.Double((double)1.0);
+var59.addFirst((java.lang.Object)var60);
+boolean var62 = var55.addAll((int)var58, (java2.util2.Collection)var59);
+java.lang.Integer var63 = new java.lang.Integer((int)0);
+java.lang.Object var64 = null;
+java.lang.Object var65 = var59.set((int)var63, (java.lang.Object)var64);
+java.lang.Integer var66 = new java.lang.Integer((int)0);
+java.lang.Object var67 = new java.lang.Object();
+var59.add((int)var66, (java.lang.Object)var67);
+java.lang.String var69 = var59.toString();
+java.lang.Object var70 = null;
+int var71 = var59.lastIndexOf((java.lang.Object)var70);
+java.lang.Integer var72 = new java.lang.Integer((int)0);
+java.lang.Integer var73 = new java.lang.Integer((int)0);
+java2.util2.List var74 = var59.subList((int)var72, (int)var73);
+boolean var75 = var4.addAll((java2.util2.Collection)var74);
+
+Variables: [var72:[0], var73:[0]]
+      public ListIterator listIterator(final int index) {
+          checkForComodification();
+>>        if (index<0 || index>size)
+              throw new IndexOutOfBoundsException(
+                  "Index: "+index+", Size: "+size);
+  
+          return new ListIterator() {
+              private ListIterator i = l.listIterator(index+offset);
+  
+              public boolean hasNext() {
+                  return nextIndex() < size;
+              }
+  
+              public Object next() {
+                  if (hasNext())
+                      return i.next();
+                  else
+                      throw new NoSuchElementException();
+              }
+  
+              public boolean hasPrevious() {
+                  return previousIndex() >= 0;
+              }
+  
+              public Object previous() {
+                  if (hasPrevious())
+                      return i.previous();
+                  else
+                      throw new NoSuchElementException();
+              }
+  
+              public int nextIndex() {
+                  return i.nextIndex() - offset;
+              }
+  
+              public int previousIndex() {
+                  return i.previousIndex() - offset;
+              }
+  
+              public void remove() {
+                  i.remove();
+                  expectedModCount = l.modCount;
+                  size--;
+                  modCount++;
+              }
+  
+              public void set(Object o) {
+                  i.set(o);
+              }
+  
+              public void add(Object o) {
+                  i.add(o);
+                  expectedModCount = l.modCount;
+                  size++;
+                  modCount++;
+              }
+          };
+      }
+
+
+WILL TRY TO REPLACE var73 WITH var72
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.SubList,methodname=listIterator,line=785,id=6,direction=true
+WILL TRY REPLACING var72 WITH VALUE 0
+WILL TRY NEGATING var72
+WILL TRY SETTING TO ZERO var72
+WILL TRY ADDING 1 var72
+WILL TRY SUBTRACTING 1 var72
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.SubList,methodname=listIterator,line=785,id=6,direction=true
+WILL TRY REPLACING var73 WITH VALUE 0
+WILL TRY NEGATING var73
+WILL TRY SETTING TO ZERO var73
+WILL TRY ADDING 1 var73
+WILL TRY SUBTRACTING 1 var73
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.Observable,methodname=addObserver,line=65,id=0,direction=true
+SEQUENCE
+var0 =  cons : java2.util2.Observable.<init>() : 
+var1 =  method : java2.util2.Observable.hasChanged() : var0 
+var2 =  prim : java2.util2.Observer:null : 
+var3 =  method : java2.util2.Observable.addObserver(java2.util2.Observer) : var0 var2 
+
+END RECORD
+
+As source code:
+java2.util2.Observable var0 = new java2.util2.Observable();
+boolean var1 = var0.hasChanged();
+java2.util2.Observer var2 = null;
+var0.addObserver((java2.util2.Observer)var2);
+
+Variables: [var2:[null]]
+      /**
+       * Adds an observer to the set of observers for this object, provided 
+       * that it is not the same as some observer already in the set. 
+       * The order in which notifications will be delivered to multiple 
+       * observers is not specified. See the class comment.
+       *
+       * @param   o   an observer to be added.
+       * @throws NullPointerException   if the parameter o is null.
+       */
+      public synchronized void addObserver(Observer o) {
+>>        if (o == null)
+              throw new NullPointerException();
+  	if (!obs.contains(o)) {
+  	    obs.addElement(o);
+  	}
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Observable,methodname=addObserver,line=65,id=0,direction=false
+NO COMPONENTS.
+FAILURE
+============================================================
+
+    // Will never work, because we don't know how to create an observer.
+
+START RECORD
+BRANCH 
+classname=java2.util2.Vector,methodname=indexOf,line=357,id=7,direction=true
+SEQUENCE
+var0 =  cons : java2.util2.Observable.<init>() : 
+var1 =  prim : java2.util2.Observer:null : 
+var2 =  method : java2.util2.Observable.deleteObserver(java2.util2.Observer) : var0 var1 
+
+END RECORD
+
+As source code:
+java2.util2.Observable var0 = new java2.util2.Observable();
+java2.util2.Observer var1 = null;
+var0.deleteObserver((java2.util2.Observer)var1);
+
+Variables: [var1:[null]]
+      /**
+       * Searches for the first occurence of the given argument, beginning 
+       * the search at <code>index</code>, and testing for equality using 
+       * the <code>equals</code> method. 
+       *
+       * @param   elem    an object.
+       * @param   index   the non-negative index to start searching from.
+       * @return  the index of the first occurrence of the object argument in
+       *          this vector at position <code>index</code> or later in the
+       *          vector, that is, the smallest value <tt>k</tt> such that 
+       *          <tt>elem.equals(elementData[k]) && (k &gt;= index)</tt> is 
+       *          <tt>true</tt>; returns <code>-1</code> if the object is not 
+       *          found. (Returns <code>-1</code> if <tt>index</tt> &gt;= the
+       *          current size of this <tt>Vector</tt>.)
+       * @exception  IndexOutOfBoundsException  if <tt>index</tt> is negative.
+       * @see     Object#equals(Object)
+       */
+      public synchronized int indexOf(Object elem, int index) {
+>>	if (elem == null) {
+  	    for (int i = index ; i < elementCount ; i++)
+  		if (elementData[i]==null)
+  		    return i;
+  	} else {
+  	    for (int i = index ; i < elementCount ; i++)
+  		if (elem.equals(elementData[i]))
+  		    return i;
+  	}
+  	return -1;
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Vector,methodname=indexOf,line=357,id=7,direction=false
+NO COMPONENTS.
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.TreeMap,methodname=buildFromSorted,line=1587,id=80,direction=true
+SEQUENCE
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : char:23 : 
+var2 =  prim : float:10.0 : 
+var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  method : java2.util2.TreeMap.clone() : var0 
+
+END RECORD
+
+As source code:
+java2.util2.TreeMap var0 = new java2.util2.TreeMap();
+java.lang.Character var1 = new java.lang.Character((char)'#');
+java.lang.Float var2 = new java.lang.Float((float)10.0);
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java.lang.Object var4 = var0.clone();
+
+Variables: [var3:[null]]
+      /**
+       * Recursive "helper method" that does the real work of the
+       * of the previous method.  Identically named parameters have
+       * identical definitions.  Additional parameters are documented below.
+       * It is assumed that the comparator and size fields of the TreeMap are
+       * already set prior to calling this method.  (It ignores both fields.)
+       *
+       * @param level the current level of tree. Initial call should be 0.
+       * @param lo the first element index of this subtree. Initial should be 0.
+       * @param hi the last element index of this subtree.  Initial should be
+       *              size-1.
+       * @param redLevel the level at which nodes should be red. 
+       *        Must be equal to computeRedLevel for tree of this size.
+       */
+      private static Entry buildFromSorted(int level, int lo, int hi,
+                                           int redLevel,
+                                           Iterator it, 
+                                           java.io.ObjectInputStream str,
+                                           Object defaultVal) 
+          throws  java.io.IOException, ClassNotFoundException {
+          /*
+           * Strategy: The root is the middlemost element. To get to it, we
+           * have to first recursively construct the entire left subtree,
+           * so as to grab all of its elements. We can then proceed with right
+           * subtree. 
+           *
+           * The lo and hi arguments are the minimum and maximum
+           * indices to pull out of the iterator or stream for current subtree.
+           * They are not actually indexed, we just proceed sequentially,
+           * ensuring that items are extracted in corresponding order.
+           */
+  
+          if (hi < lo) return null;
+  
+          int mid = (lo + hi) / 2;
+          
+          Entry left  = null;
+          if (lo < mid) 
+              left = buildFromSorted(level+1, lo, mid - 1, redLevel,
+                                     it, str, defaultVal);
+          
+          // extract key and/or value from iterator or stream
+          Object key;
+          Object value;
+          if (it != null) { // use iterator
+>>            if (defaultVal==null) {
+                  Map.Entry entry = (Map.Entry) it.next();
+                  key = entry.getKey();
+                  value = entry.getValue();
+              } else {
+                  key = it.next();
+                  value = defaultVal;
+              }
+          } else { // use stream
+              key = str.readObject();
+              value = (defaultVal != null ? defaultVal : str.readObject());
+          }
+  
+          Entry middle =  new Entry(key, value, null);
+          
+          // color nodes in non-full bottommost level red
+          if (level == redLevel)
+              middle.color = RED;
+          
+          if (left != null) { 
+              middle.left = left; 
+              left.parent = middle; 
+          }
+          
+          if (mid < hi) {
+              Entry right = buildFromSorted(level+1, mid+1, hi, redLevel,
+                                            it, str, defaultVal);
+              middle.right = right;
+              right.parent = middle;
+          }
+          
+          return middle;
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=buildFromSorted,line=1587,id=80,direction=false
+REPLACING ALL USES OF var3 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : char:23 : 
+var2 =  prim : float:10.0 : 
+var3 =  prim : java.lang.Object:null : 
+var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var5 =  method : java2.util2.TreeMap.clone() : var0 
+
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.TreeMap,methodname=buildFromSorted,line=1606,id=82,direction=false
+SEQUENCE
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : char:23 : 
+var2 =  prim : float:10.0 : 
+var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  method : java2.util2.TreeMap.clone() : var0 
+
+END RECORD
+
+As source code:
+java2.util2.TreeMap var0 = new java2.util2.TreeMap();
+java.lang.Character var1 = new java.lang.Character((char)'#');
+java.lang.Float var2 = new java.lang.Float((float)10.0);
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java.lang.Object var4 = var0.clone();
+
+Variables: [var3:[null]]
+      /**
+       * Recursive "helper method" that does the real work of the
+       * of the previous method.  Identically named parameters have
+       * identical definitions.  Additional parameters are documented below.
+       * It is assumed that the comparator and size fields of the TreeMap are
+       * already set prior to calling this method.  (It ignores both fields.)
+       *
+       * @param level the current level of tree. Initial call should be 0.
+       * @param lo the first element index of this subtree. Initial should be 0.
+       * @param hi the last element index of this subtree.  Initial should be
+       *              size-1.
+       * @param redLevel the level at which nodes should be red. 
+       *        Must be equal to computeRedLevel for tree of this size.
+       */
+      private static Entry buildFromSorted(int level, int lo, int hi,
+                                           int redLevel,
+                                           Iterator it, 
+                                           java.io.ObjectInputStream str,
+                                           Object defaultVal) 
+          throws  java.io.IOException, ClassNotFoundException {
+          /*
+           * Strategy: The root is the middlemost element. To get to it, we
+           * have to first recursively construct the entire left subtree,
+           * so as to grab all of its elements. We can then proceed with right
+           * subtree. 
+           *
+           * The lo and hi arguments are the minimum and maximum
+           * indices to pull out of the iterator or stream for current subtree.
+           * They are not actually indexed, we just proceed sequentially,
+           * ensuring that items are extracted in corresponding order.
+           */
+  
+          if (hi < lo) return null;
+  
+          int mid = (lo + hi) / 2;
+          
+          Entry left  = null;
+          if (lo < mid) 
+              left = buildFromSorted(level+1, lo, mid - 1, redLevel,
+                                     it, str, defaultVal);
+          
+          // extract key and/or value from iterator or stream
+          Object key;
+          Object value;
+          if (it != null) { // use iterator
+              if (defaultVal==null) {
+                  Map.Entry entry = (Map.Entry) it.next();
+                  key = entry.getKey();
+                  value = entry.getValue();
+              } else {
+                  key = it.next();
+                  value = defaultVal;
+              }
+          } else { // use stream
+              key = str.readObject();
+              value = (defaultVal != null ? defaultVal : str.readObject());
+          }
+  
+          Entry middle =  new Entry(key, value, null);
+          
+          // color nodes in non-full bottommost level red
+          if (level == redLevel)
+              middle.color = RED;
+          
+>>        if (left != null) { 
+              middle.left = left; 
+              left.parent = middle; 
+          }
+          
+          if (mid < hi) {
+              Entry right = buildFromSorted(level+1, mid+1, hi, redLevel,
+                                            it, str, defaultVal);
+              middle.right = right;
+              right.parent = middle;
+          }
+          
+          return middle;
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=buildFromSorted,line=1606,id=82,direction=true
+REPLACING ALL USES OF var3 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : char:23 : 
+var2 =  prim : float:10.0 : 
+var3 =  prim : java.lang.Object:null : 
+var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var5 =  method : java2.util2.TreeMap.clone() : var0 
+
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.TreeMap,methodname=deleteEntry,line=1335,id=58,direction=false
+SEQUENCE
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : int:1 : 
+var2 =  prim : java.lang.Object:null : 
+var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  prim : int:1 : 
+var5 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var4 
+
+END RECORD
+
+As source code:
+java2.util2.TreeMap var0 = new java2.util2.TreeMap();
+java.lang.Integer var1 = new java.lang.Integer((int)1);
+java.lang.Object var2 = null;
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java.lang.Integer var4 = new java.lang.Integer((int)1);
+java.lang.Object var5 = var0.remove((java.lang.Object)var4);
+
+Variables: [var3:[null], var5:[null], var2:[null]]
+      /**
+       * Delete node p, and then rebalance the tree.
+       */
+  
+      private void deleteEntry(Entry p) {
+          decrementSize();
+  
+          // If strictly internal, copy successor's element to p and then make p
+          // point to successor.
+>>        if (p.left != null && p.right != null) {
+              Entry s = successor (p);
+              p.key = s.key;       
+              p.value = s.value;  
+              p = s;
+          } // p has 2 children
+  
+          // Start fixup at replacement node, if it exists.
+          Entry replacement = (p.left != null ? p.left : p.right);
+  
+          if (replacement != null) {
+              // Link replacement to parent
+              replacement.parent = p.parent;
+              if (p.parent == null)
+                  root = replacement;
+              else if (p == p.parent.left)
+                  p.parent.left  = replacement;
+              else
+                  p.parent.right = replacement;
+  
+              // Null out links so they are OK to use by fixAfterDeletion.
+              p.left = p.right = p.parent = null;
+  
+              // Fix replacement
+              if (p.color == BLACK)
+                  fixAfterDeletion(replacement);
+          } else if (p.parent == null) { // return if we are the only node.
+              root = null;
+          } else { //  No children. Use self as phantom replacement and unlink.
+              if (p.color == BLACK)
+                  fixAfterDeletion(p);
+  
+              if (p.parent != null) {
+                  if (p == p.parent.left)
+                      p.parent.left = null;
+                  else if (p == p.parent.right)
+                      p.parent.right = null;
+                  p.parent = null;
+              }
+          }
+      }
+
+
+WILL TRY TO REPLACE var3 WITH var2
+WILL TRY TO REPLACE var5 WITH var2
+WILL TRY TO REPLACE var5 WITH var3
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1335,id=58,direction=true
+REPLACING ALL USES OF var3 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : int:1 : 
+var2 =  prim : java.lang.Object:null : 
+var3 =  prim : java.lang.Object:null : 
+var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var5 =  prim : int:1 : 
+var6 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var5 
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1335,id=58,direction=true
+REPLACING ALL USES OF var5 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : int:1 : 
+var2 =  prim : java.lang.Object:null : 
+var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  prim : int:1 : 
+var5 =  prim : java.lang.Object:null : 
+var6 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var4 
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1335,id=58,direction=true
+WILL USE:
+var0 =  prim : byte:-1 : 
+
+
+REPLACING ALL USES OF var2 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : int:1 : 
+var2 =  prim : byte:-1 : 
+var3 =  prim : java.lang.Object:null : 
+var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var5 =  prim : int:1 : 
+var6 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var5 
+
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.TreeMap,methodname=deleteEntry,line=1345,id=59,direction=false
+SEQUENCE
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : int:1 : 
+var2 =  prim : java.lang.Object:null : 
+var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  prim : int:1 : 
+var5 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var4 
+
+END RECORD
+
+As source code:
+java2.util2.TreeMap var0 = new java2.util2.TreeMap();
+java.lang.Integer var1 = new java.lang.Integer((int)1);
+java.lang.Object var2 = null;
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java.lang.Integer var4 = new java.lang.Integer((int)1);
+java.lang.Object var5 = var0.remove((java.lang.Object)var4);
+
+Variables: [var2:[null], var5:[null], var3:[null]]
+      /**
+       * Delete node p, and then rebalance the tree.
+       */
+  
+      private void deleteEntry(Entry p) {
+          decrementSize();
+  
+          // If strictly internal, copy successor's element to p and then make p
+          // point to successor.
+          if (p.left != null && p.right != null) {
+              Entry s = successor (p);
+              p.key = s.key;       
+              p.value = s.value;  
+              p = s;
+          } // p has 2 children
+  
+          // Start fixup at replacement node, if it exists.
+          Entry replacement = (p.left != null ? p.left : p.right);
+  
+>>        if (replacement != null) {
+              // Link replacement to parent
+              replacement.parent = p.parent;
+              if (p.parent == null)
+                  root = replacement;
+              else if (p == p.parent.left)
+                  p.parent.left  = replacement;
+              else
+                  p.parent.right = replacement;
+  
+              // Null out links so they are OK to use by fixAfterDeletion.
+              p.left = p.right = p.parent = null;
+  
+              // Fix replacement
+              if (p.color == BLACK)
+                  fixAfterDeletion(replacement);
+          } else if (p.parent == null) { // return if we are the only node.
+              root = null;
+          } else { //  No children. Use self as phantom replacement and unlink.
+              if (p.color == BLACK)
+                  fixAfterDeletion(p);
+  
+              if (p.parent != null) {
+                  if (p == p.parent.left)
+                      p.parent.left = null;
+                  else if (p == p.parent.right)
+                      p.parent.right = null;
+                  p.parent = null;
+              }
+          }
+      }
+
+
+WILL TRY TO REPLACE var3 WITH var2
+WILL TRY TO REPLACE var5 WITH var2
+WILL TRY TO REPLACE var5 WITH var3
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1345,id=59,direction=true
+WILL USE:
+var0 =  prim : byte:-1 : 
+
+
+REPLACING ALL USES OF var2 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : int:1 : 
+var2 =  prim : byte:-1 : 
+var3 =  prim : java.lang.Object:null : 
+var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var5 =  prim : int:1 : 
+var6 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var5 
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1345,id=59,direction=true
+REPLACING ALL USES OF var5 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : int:1 : 
+var2 =  prim : java.lang.Object:null : 
+var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  prim : int:1 : 
+var5 =  prim : java.lang.Object:null : 
+var6 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var4 
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1345,id=59,direction=true
+REPLACING ALL USES OF var3 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : int:1 : 
+var2 =  prim : java.lang.Object:null : 
+var3 =  prim : java.lang.Object:null : 
+var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var5 =  prim : int:1 : 
+var6 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var5 
+
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.TreeMap,methodname=deleteEntry,line=1361,id=63,direction=true
+SEQUENCE
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : int:1 : 
+var2 =  prim : java.lang.Object:null : 
+var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  prim : int:1 : 
+var5 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var4 
+
+END RECORD
+
+As source code:
+java2.util2.TreeMap var0 = new java2.util2.TreeMap();
+java.lang.Integer var1 = new java.lang.Integer((int)1);
+java.lang.Object var2 = null;
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java.lang.Integer var4 = new java.lang.Integer((int)1);
+java.lang.Object var5 = var0.remove((java.lang.Object)var4);
+
+Variables: [var2:[null], var5:[null], var3:[null]]
+      /**
+       * Delete node p, and then rebalance the tree.
+       */
+  
+      private void deleteEntry(Entry p) {
+          decrementSize();
+  
+          // If strictly internal, copy successor's element to p and then make p
+          // point to successor.
+          if (p.left != null && p.right != null) {
+              Entry s = successor (p);
+              p.key = s.key;       
+              p.value = s.value;  
+              p = s;
+          } // p has 2 children
+  
+          // Start fixup at replacement node, if it exists.
+          Entry replacement = (p.left != null ? p.left : p.right);
+  
+          if (replacement != null) {
+              // Link replacement to parent
+              replacement.parent = p.parent;
+              if (p.parent == null)
+                  root = replacement;
+              else if (p == p.parent.left)
+                  p.parent.left  = replacement;
+              else
+                  p.parent.right = replacement;
+  
+              // Null out links so they are OK to use by fixAfterDeletion.
+              p.left = p.right = p.parent = null;
+  
+              // Fix replacement
+              if (p.color == BLACK)
+                  fixAfterDeletion(replacement);
+>>        } else if (p.parent == null) { // return if we are the only node.
+              root = null;
+          } else { //  No children. Use self as phantom replacement and unlink.
+              if (p.color == BLACK)
+                  fixAfterDeletion(p);
+  
+              if (p.parent != null) {
+                  if (p == p.parent.left)
+                      p.parent.left = null;
+                  else if (p == p.parent.right)
+                      p.parent.right = null;
+                  p.parent = null;
+              }
+          }
+      }
+
+
+WILL TRY TO REPLACE var3 WITH var2
+WILL TRY TO REPLACE var5 WITH var2
+WILL TRY TO REPLACE var5 WITH var3
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1361,id=63,direction=false
+WILL USE:
+var0 =  prim : byte:-1 : 
+
+
+REPLACING ALL USES OF var2 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : int:1 : 
+var2 =  prim : byte:-1 : 
+var3 =  prim : java.lang.Object:null : 
+var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var5 =  prim : int:1 : 
+var6 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var5 
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1361,id=63,direction=false
+REPLACING ALL USES OF var5 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : int:1 : 
+var2 =  prim : java.lang.Object:null : 
+var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  prim : int:1 : 
+var5 =  prim : java.lang.Object:null : 
+var6 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var4 
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1361,id=63,direction=false
+REPLACING ALL USES OF var3 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : int:1 : 
+var2 =  prim : java.lang.Object:null : 
+var3 =  prim : java.lang.Object:null : 
+var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var5 =  prim : int:1 : 
+var6 =  method : java2.util2.TreeMap.remove(java.lang.Object) : var0 var5 
+
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.TreeMap,methodname=firstEntry,line=1180,id=36,direction=false
+SEQUENCE
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : char:23 : 
+var2 =  prim : float:10.0 : 
+var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  method : java2.util2.TreeMap.firstKey() : var0 
+
+END RECORD
+
+As source code:
+java2.util2.TreeMap var0 = new java2.util2.TreeMap();
+java.lang.Character var1 = new java.lang.Character((char)'#');
+java.lang.Float var2 = new java.lang.Float((float)10.0);
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java.lang.Object var4 = var0.firstKey();
+
+Variables: [var3:[null]]
+      /**
+       * Returns the first Entry in the TreeMap (according to the TreeMap's
+       * key-sort function).  Returns null if the TreeMap is empty.
+       */
+      private Entry firstEntry() {
+          Entry p = root;
+          if (p != null)
+>>            while (p.left != null)
+                  p = p.left;
+          return p;
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=firstEntry,line=1180,id=36,direction=true
+REPLACING ALL USES OF var3 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : char:23 : 
+var2 =  prim : float:10.0 : 
+var3 =  prim : java.lang.Object:null : 
+var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var5 =  method : java2.util2.TreeMap.firstKey() : var0 
+
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.TreeMap,methodname=lastEntry,line=1192,id=38,direction=false
+SEQUENCE
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : char:61 : 
+var2 =  prim : java.lang.Object:null : 
+var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  method : java2.util2.TreeMap.lastKey() : var0 
+
+END RECORD
+
+As source code:
+java2.util2.TreeMap var0 = new java2.util2.TreeMap();
+java.lang.Character var1 = new java.lang.Character((char)'a');
+java.lang.Object var2 = null;
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java.lang.Object var4 = var0.lastKey();
+
+Variables: [var2:[null], var3:[null]]
+      /**
+       * Returns the last Entry in the TreeMap (according to the TreeMap's
+       * key-sort function).  Returns null if the TreeMap is empty.
+       */
+      private Entry lastEntry() {
+          Entry p = root;
+          if (p != null)
+>>            while (p.right != null)
+                  p = p.right;
+          return p;
+      }
+
+
+WILL TRY TO REPLACE var3 WITH var2
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=lastEntry,line=1192,id=38,direction=true
+WILL USE:
+var0 =  prim : byte:-1 : 
+
+
+REPLACING ALL USES OF var2 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : char:61 : 
+var2 =  prim : byte:-1 : 
+var3 =  prim : java.lang.Object:null : 
+var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var5 =  method : java2.util2.TreeMap.lastKey() : var0 
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=lastEntry,line=1192,id=38,direction=true
+REPLACING ALL USES OF var3 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : char:61 : 
+var2 =  prim : java.lang.Object:null : 
+var3 =  prim : java.lang.Object:null : 
+var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var5 =  method : java2.util2.TreeMap.lastKey() : var0 
+
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.TreeMap,methodname=putAll,line=316,id=3,direction=true
+SEQUENCE
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : char:61 : 
+var2 =  prim : java.lang.Object:null : 
+var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  cons : java2.util2.TreeMap.<init>(java2.util2.Map) : var0 
+
+END RECORD
+
+As source code:
+java2.util2.TreeMap var0 = new java2.util2.TreeMap();
+java.lang.Character var1 = new java.lang.Character((char)'a');
+java.lang.Object var2 = null;
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java2.util2.TreeMap var4 = new java2.util2.TreeMap((java2.util2.Map)var0);
+
+Variables: [var3:[object], var2:[object]]
+      /**
+       * Copies all of the mappings from the specified map to this map.  These
+       * mappings replace any mappings that this map had for any of the keys
+       * currently in the specified map.
+       *
+       * @param     map mappings to be stored in this map.
+       * @throws    ClassCastException class of a key or value in the specified
+       *                   map prevents it from being stored in this map.
+       * 
+       * @throws NullPointerException if the given map is <tt>null</tt> or
+       *         this map does not permit <tt>null</tt> keys and a 
+       *         key in the specified map is <tt>null</tt>.
+       */
+      public void putAll(Map map) {
+          int mapSize = map.size();
+          if (size==0 && mapSize!=0 && map instanceof SortedMap) {
+              Comparator c = ((SortedMap)map).comparator();
+>>            if (c == comparator || (c != null && c.equals(comparator))) {
+                ++modCount;
+                try {
+                    buildFromSorted(mapSize, map.entrySet().iterator(),
+                                    null, null);
+                } catch (java.io.IOException cannotHappen) {
+                } catch (ClassNotFoundException cannotHappen) {
+                }
+                return;
+              }
+          }
+          super.putAll(map);
+      }
+
+
+WILL TRY TO REPLACE var3 WITH var2
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=putAll,line=316,id=3,direction=false
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=putAll,line=316,id=3,direction=false
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.TreeMap,methodname=successor,line=1203,id=40,direction=false
+SEQUENCE
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : char:23 : 
+var2 =  prim : float:10.0 : 
+var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  method : java2.util2.TreeMap.clone() : var0 
+
+END RECORD
+
+As source code:
+java2.util2.TreeMap var0 = new java2.util2.TreeMap();
+java.lang.Character var1 = new java.lang.Character((char)'#');
+java.lang.Float var2 = new java.lang.Float((float)10.0);
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java.lang.Object var4 = var0.clone();
+
+Variables: [var3:[null]]
+      /**
+       * Returns the successor of the specified Entry, or null if no such.
+       */
+      private Entry successor(Entry t) {
+          if (t == null)
+              return null;
+>>        else if (t.right != null) {
+              Entry p = t.right;
+              while (p.left != null)
+                  p = p.left;
+              return p;
+          } else {
+              Entry p = t.parent;
+              Entry ch = t;
+              while (p != null && ch == p.right) {
+                  ch = p;
+                  p = p.parent;
+              }
+              return p;
+          }
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=successor,line=1203,id=40,direction=true
+REPLACING ALL USES OF var3 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : char:23 : 
+var2 =  prim : float:10.0 : 
+var3 =  prim : java.lang.Object:null : 
+var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var5 =  method : java2.util2.TreeMap.clone() : var0 
+
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.TreeMap,methodname=successor,line=1211,id=42,direction=false
+SEQUENCE
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : char:23 : 
+var2 =  prim : float:10.0 : 
+var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  method : java2.util2.TreeMap.clone() : var0 
+
+END RECORD
+
+As source code:
+java2.util2.TreeMap var0 = new java2.util2.TreeMap();
+java.lang.Character var1 = new java.lang.Character((char)'#');
+java.lang.Float var2 = new java.lang.Float((float)10.0);
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java.lang.Object var4 = var0.clone();
+
+Variables: [var3:[null]]
+      /**
+       * Returns the successor of the specified Entry, or null if no such.
+       */
+      private Entry successor(Entry t) {
+          if (t == null)
+              return null;
+          else if (t.right != null) {
+              Entry p = t.right;
+              while (p.left != null)
+                  p = p.left;
+              return p;
+          } else {
+              Entry p = t.parent;
+              Entry ch = t;
+>>            while (p != null && ch == p.right) {
+                  ch = p;
+                  p = p.parent;
+              }
+              return p;
+          }
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=successor,line=1211,id=42,direction=true
+REPLACING ALL USES OF var3 WITH var0
+NEW SEQUENCE: 
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : char:23 : 
+var2 =  prim : float:10.0 : 
+var3 =  prim : java.lang.Object:null : 
+var4 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var5 =  method : java2.util2.TreeMap.clone() : var0 
+
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.TreeMap,methodname=valueSearchNonNull,line=236,id=1,direction=false
+SEQUENCE
+var0 =  cons : java2.util2.TreeMap.<init>() : 
+var1 =  prim : int:1 : 
+var2 =  prim : java.lang.Object:null : 
+var3 =  method : java2.util2.TreeMap.put(java.lang.Object,java.lang.Object) : var0 var1 var2 
+var4 =  prim : boolean:false : 
+var5 =  method : java2.util2.TreeMap.containsValue(java.lang.Object) : var0 var4 
+
+END RECORD
+
+As source code:
+java2.util2.TreeMap var0 = new java2.util2.TreeMap();
+java.lang.Integer var1 = new java.lang.Integer((int)1);
+java.lang.Object var2 = null;
+java.lang.Object var3 = var0.put((java.lang.Object)var1, (java.lang.Object)var2);
+java.lang.Boolean var4 = new java.lang.Boolean((boolean)false);
+boolean var5 = var0.containsValue((java.lang.Object)var4);
+
+Variables: [var4:[0], var3:[0], var2:[0]]
+      private boolean valueSearchNonNull(Entry n, Object value) {
+          // Check this node for the value
+>>        if (value.equals(n.value))
+              return true;
+  
+          // Check left and right subtrees for value
+          return (n.left  != null && valueSearchNonNull(n.left, value)) ||
+                 (n.right != null && valueSearchNonNull(n.right, value));
+      }
+
+
+WILL TRY TO REPLACE var3 WITH var2
+WILL TRY TO REPLACE var4 WITH var2
+WILL TRY TO REPLACE var4 WITH var3
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=valueSearchNonNull,line=236,id=1,direction=true
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=valueSearchNonNull,line=236,id=1,direction=true
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=valueSearchNonNull,line=236,id=1,direction=true
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.AbstractMap,methodname=keySet,line=371,id=22,direction=true
+SEQUENCE
+var0 =  prim : java2.util2.Comparator:null : 
+var1 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
+var2 =  prim : int:0 : 
+var3 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var2 
+var4 =  prim : char:20 : 
+var5 =  method : java2.util2.TreeSet.headSet(java.lang.Object) : var1 var4 
+
+END RECORD
+
+As source code:
+java2.util2.Comparator var0 = null;
+java2.util2.TreeSet var1 = new java2.util2.TreeSet((java2.util2.Comparator)var0);
+java.lang.Integer var2 = new java.lang.Integer((int)0);
+boolean var3 = var1.add((java.lang.Object)var2);
+java.lang.Character var4 = new java.lang.Character((char)' ');
+java2.util2.SortedSet var5 = var1.headSet((java.lang.Object)var4);
+
+Variables: [var0:[null]]
+      /**
+       * Returns a Set view of the keys contained in this map.  The Set is
+       * backed by the map, so changes to the map are reflected in the Set,
+       * and vice-versa.  (If the map is modified while an iteration over
+       * the Set is in progress, the results of the iteration are undefined.)
+       * The Set supports element removal, which removes the corresponding entry
+       * from the map, via the Iterator.remove, Set.remove,  removeAll
+       * retainAll, and clear operations.  It does not support the add or
+       * addAll operations.<p>
+       *
+       * This implementation returns a Set that subclasses
+       * AbstractSet.  The subclass's iterator method returns a "wrapper
+       * object" over this map's entrySet() iterator.  The size method delegates
+       * to this map's size method and the contains method delegates to this
+       * map's containsKey method.<p>
+       *
+       * The Set is created the first time this method is called,
+       * and returned in response to all subsequent calls.  No synchronization
+       * is performed, so there is a slight chance that multiple calls to this
+       * method will not all return the same Set.
+       *
+       * @return a Set view of the keys contained in this map.
+       */
+      public Set keySet() {
+>>	if (keySet == null) {
+  	    keySet = new AbstractSet() {
+  		public Iterator iterator() {
+  		    return new Iterator() {
+  			private Iterator i = entrySet().iterator();
+  
+  			public boolean hasNext() {
+  			    return i.hasNext();
+  			}
+  
+  			public Object next() {
+  			    return ((Entry)i.next()).getKey();
+  			}
+  
+  			public void remove() {
+  			    i.remove();
+  			}
+                      };
+  		}
+  
+  		public int size() {
+  		    return AbstractMap.this.size();
+  		}
+  
+  		public boolean contains(Object k) {
+  		    return AbstractMap.this.containsKey(k);
+  		}
+  	    };
+  	}
+  	return keySet;
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.AbstractMap,methodname=keySet,line=371,id=22,direction=false
+WILL USE:
+var0 =  method : java2.util2.Collections.reverseOrder() : 
+
+
+REPLACING ALL USES OF var0 WITH var0
+NEW SEQUENCE: 
+var0 =  method : java2.util2.Collections.reverseOrder() : 
+var1 =  prim : java2.util2.Comparator:null : 
+var2 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
+var3 =  prim : int:0 : 
+var4 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var3 
+var5 =  prim : char:20 : 
+var6 =  method : java2.util2.TreeSet.headSet(java.lang.Object) : var2 var5 
+
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.TreeMap,methodname=deleteEntry,line=1335,id=58,direction=false
+SEQUENCE
+var0 =  prim : java2.util2.Comparator:null : 
+var1 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
+var2 =  prim : int:0 : 
+var3 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var2 
+var4 =  prim : int:-1 : 
+var5 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var4 
+var6 =  prim : java2.util2.Comparator:null : 
+var7 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var6 
+var8 =  method : java2.util2.AbstractCollection.retainAll(java2.util2.Collection) : var1 var7 
+
+END RECORD
+
+As source code:
+java2.util2.Comparator var0 = null;
+java2.util2.TreeSet var1 = new java2.util2.TreeSet((java2.util2.Comparator)var0);
+java.lang.Integer var2 = new java.lang.Integer((int)0);
+boolean var3 = var1.add((java.lang.Object)var2);
+java.lang.Integer var4 = new java.lang.Integer((int)-1);
+boolean var5 = var1.add((java.lang.Object)var4);
+java2.util2.Comparator var6 = null;
+java2.util2.TreeSet var7 = new java2.util2.TreeSet((java2.util2.Comparator)var6);
+boolean var8 = var1.retainAll((java2.util2.Collection)var7);
+
+Variables: [var0:[null], var6:[null]]
+      /**
+       * Delete node p, and then rebalance the tree.
+       */
+  
+      private void deleteEntry(Entry p) {
+          decrementSize();
+  
+          // If strictly internal, copy successor's element to p and then make p
+          // point to successor.
+>>        if (p.left != null && p.right != null) {
+              Entry s = successor (p);
+              p.key = s.key;       
+              p.value = s.value;  
+              p = s;
+          } // p has 2 children
+  
+          // Start fixup at replacement node, if it exists.
+          Entry replacement = (p.left != null ? p.left : p.right);
+  
+          if (replacement != null) {
+              // Link replacement to parent
+              replacement.parent = p.parent;
+              if (p.parent == null)
+                  root = replacement;
+              else if (p == p.parent.left)
+                  p.parent.left  = replacement;
+              else
+                  p.parent.right = replacement;
+  
+              // Null out links so they are OK to use by fixAfterDeletion.
+              p.left = p.right = p.parent = null;
+  
+              // Fix replacement
+              if (p.color == BLACK)
+                  fixAfterDeletion(replacement);
+          } else if (p.parent == null) { // return if we are the only node.
+              root = null;
+          } else { //  No children. Use self as phantom replacement and unlink.
+              if (p.color == BLACK)
+                  fixAfterDeletion(p);
+  
+              if (p.parent != null) {
+                  if (p == p.parent.left)
+                      p.parent.left = null;
+                  else if (p == p.parent.right)
+                      p.parent.right = null;
+                  p.parent = null;
+              }
+          }
+      }
+
+
+WILL TRY TO REPLACE var6 WITH var0
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1335,id=58,direction=true
+WILL USE:
+var0 =  method : java2.util2.Collections.reverseOrder() : 
+
+
+REPLACING ALL USES OF var0 WITH var0
+NEW SEQUENCE: 
+var0 =  method : java2.util2.Collections.reverseOrder() : 
+var1 =  prim : java2.util2.Comparator:null : 
+var2 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
+var3 =  prim : int:0 : 
+var4 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var3 
+var5 =  prim : int:-1 : 
+var6 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var5 
+var7 =  prim : java2.util2.Comparator:null : 
+var8 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var7 
+var9 =  method : java2.util2.AbstractCollection.retainAll(java2.util2.Collection) : var2 var8 
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=deleteEntry,line=1335,id=58,direction=true
+WILL USE:
+var0 =  method : java2.util2.Collections.reverseOrder() : 
+
+
+REPLACING ALL USES OF var6 WITH var0
+NEW SEQUENCE: 
+var0 =  prim : java2.util2.Comparator:null : 
+var1 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
+var2 =  prim : int:0 : 
+var3 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var2 
+var4 =  prim : int:-1 : 
+var5 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var4 
+var6 =  method : java2.util2.Collections.reverseOrder() : 
+var7 =  prim : java2.util2.Comparator:null : 
+var8 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var6 
+var9 =  method : java2.util2.AbstractCollection.retainAll(java2.util2.Collection) : var1 var8 
+
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.TreeMap,methodname=put,line=467,id=22,direction=false
+SEQUENCE
+var0 =  prim : java2.util2.Comparator:null : 
+var1 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
+var2 =  prim : int:0 : 
+var3 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var2 
+var4 =  prim : int:-1 : 
+var5 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var4 
+
+END RECORD
+
+As source code:
+java2.util2.Comparator var0 = null;
+java2.util2.TreeSet var1 = new java2.util2.TreeSet((java2.util2.Comparator)var0);
+java.lang.Integer var2 = new java.lang.Integer((int)0);
+boolean var3 = var1.add((java.lang.Object)var2);
+java.lang.Integer var4 = new java.lang.Integer((int)-1);
+boolean var5 = var1.add((java.lang.Object)var4);
+
+Variables: [var0:[null]]
+      /**
+       * Associates the specified value with the specified key in this map.
+       * If the map previously contained a mapping for this key, the old
+       * value is replaced.
+       *
+       * @param key key with which the specified value is to be associated.
+       * @param value value to be associated with the specified key.
+       * 
+       * @return previous value associated with specified key, or <tt>null</tt>
+       *         if there was no mapping for key.  A <tt>null</tt> return can
+       *         also indicate that the map previously associated <tt>null</tt>
+       *         with the specified key.
+       * @throws    ClassCastException key cannot be compared with the keys
+       *            currently in the map.
+       * @throws NullPointerException key is <tt>null</tt> and this map uses
+       *         natural order, or its comparator does not tolerate
+       *         <tt>null</tt> keys.
+       */
+      public Object put(Object key, Object value) {
+          Entry t = root;
+  
+          if (t == null) {
+              incrementSize();
+              root = new Entry(key, value, null);
+              return null;
+         }
+  
+          while (true) {
+              int cmp = compare(key, t.key);
+              if (cmp == 0) {
+                  return t.setValue(value);
+              } else if (cmp < 0) {
+>>                if (t.left != null) {
+                      t = t.left;
+                  } else {
+                      incrementSize();
+                      t.left = new Entry(key, value, t);
+                      fixAfterInsertion(t.left);
+                      return null;
+                  }
+              } else { // cmp > 0
+                  if (t.right != null) {
+                      t = t.right;
+                  } else {
+                      incrementSize();
+                      t.right = new Entry(key, value, t);
+                      fixAfterInsertion(t.right);
+                      return null;
+                  }
+              }
+          }
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=put,line=467,id=22,direction=true
+WILL USE:
+var0 =  method : java2.util2.Collections.reverseOrder() : 
+
+
+REPLACING ALL USES OF var0 WITH var0
+NEW SEQUENCE: 
+var0 =  method : java2.util2.Collections.reverseOrder() : 
+var1 =  prim : java2.util2.Comparator:null : 
+var2 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
+var3 =  prim : int:0 : 
+var4 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var3 
+var5 =  prim : int:-1 : 
+var6 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var5 
+
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.TreeMap,methodname=put,line=476,id=23,direction=false
+SEQUENCE
+var0 =  prim : java2.util2.Comparator:null : 
+var1 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
+var2 =  prim : int:0 : 
+var3 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var2 
+var4 =  prim : int:-1 : 
+var5 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var4 
+var6 =  prim : int:10 : 
+var7 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var6 
+
+END RECORD
+
+As source code:
+java2.util2.Comparator var0 = null;
+java2.util2.TreeSet var1 = new java2.util2.TreeSet((java2.util2.Comparator)var0);
+java.lang.Integer var2 = new java.lang.Integer((int)0);
+boolean var3 = var1.add((java.lang.Object)var2);
+java.lang.Integer var4 = new java.lang.Integer((int)-1);
+boolean var5 = var1.add((java.lang.Object)var4);
+java.lang.Integer var6 = new java.lang.Integer((int)10);
+boolean var7 = var1.add((java.lang.Object)var6);
+
+Variables: [var0:[null]]
+      /**
+       * Associates the specified value with the specified key in this map.
+       * If the map previously contained a mapping for this key, the old
+       * value is replaced.
+       *
+       * @param key key with which the specified value is to be associated.
+       * @param value value to be associated with the specified key.
+       * 
+       * @return previous value associated with specified key, or <tt>null</tt>
+       *         if there was no mapping for key.  A <tt>null</tt> return can
+       *         also indicate that the map previously associated <tt>null</tt>
+       *         with the specified key.
+       * @throws    ClassCastException key cannot be compared with the keys
+       *            currently in the map.
+       * @throws NullPointerException key is <tt>null</tt> and this map uses
+       *         natural order, or its comparator does not tolerate
+       *         <tt>null</tt> keys.
+       */
+      public Object put(Object key, Object value) {
+          Entry t = root;
+  
+          if (t == null) {
+              incrementSize();
+              root = new Entry(key, value, null);
+              return null;
+         }
+  
+          while (true) {
+              int cmp = compare(key, t.key);
+              if (cmp == 0) {
+                  return t.setValue(value);
+              } else if (cmp < 0) {
+                  if (t.left != null) {
+                      t = t.left;
+                  } else {
+                      incrementSize();
+                      t.left = new Entry(key, value, t);
+                      fixAfterInsertion(t.left);
+                      return null;
+                  }
+              } else { // cmp > 0
+>>                if (t.right != null) {
+                      t = t.right;
+                  } else {
+                      incrementSize();
+                      t.right = new Entry(key, value, t);
+                      fixAfterInsertion(t.right);
+                      return null;
+                  }
+              }
+          }
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=put,line=476,id=23,direction=true
+WILL USE:
+var0 =  method : java2.util2.Collections.reverseOrder() : 
+
+
+REPLACING ALL USES OF var0 WITH var0
+NEW SEQUENCE: 
+var0 =  method : java2.util2.Collections.reverseOrder() : 
+var1 =  prim : java2.util2.Comparator:null : 
+var2 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
+var3 =  prim : int:0 : 
+var4 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var3 
+var5 =  prim : int:-1 : 
+var6 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var5 
+var7 =  prim : int:10 : 
+var8 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var7 
+
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.TreeMap,methodname=remove,line=505,id=24,direction=true
+SEQUENCE
+var0 =  prim : java2.util2.Comparator:null : 
+var1 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
+var2 =  prim : java.lang.Object:null : 
+var3 =  method : java2.util2.TreeSet.remove(java.lang.Object) : var1 var2 
+
+END RECORD
+
+As source code:
+java2.util2.Comparator var0 = null;
+java2.util2.TreeSet var1 = new java2.util2.TreeSet((java2.util2.Comparator)var0);
+java.lang.Object var2 = null;
+boolean var3 = var1.remove((java.lang.Object)var2);
+
+Variables: [var2:[null], var0:[null]]
+      /**
+       * Removes the mapping for this key from this TreeMap if present.
+       *
+       * @param  key key for which mapping should be removed
+       * @return previous value associated with specified key, or <tt>null</tt>
+       *         if there was no mapping for key.  A <tt>null</tt> return can
+       *         also indicate that the map previously associated
+       *         <tt>null</tt> with the specified key.
+       * 
+       * @throws    ClassCastException key cannot be compared with the keys
+       *            currently in the map.
+       * @throws NullPointerException key is <tt>null</tt> and this map uses
+       *         natural order, or its comparator does not tolerate
+       *         <tt>null</tt> keys.
+       */
+      public Object remove(Object key) {
+          Entry p = getEntry(key);
+>>        if (p == null)
+              return null;
+  
+          Object oldValue = p.value;
+          deleteEntry(p);
+          return oldValue;
+      }
+
+
+WILL TRY TO REPLACE var2 WITH var0
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=remove,line=505,id=24,direction=false
+WILL USE:
+var0 =  prim : byte:-1 : 
+
+
+REPLACING ALL USES OF var2 WITH var0
+NEW SEQUENCE: 
+var0 =  prim : java2.util2.Comparator:null : 
+var1 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
+var2 =  prim : byte:-1 : 
+var3 =  prim : java.lang.Object:null : 
+var4 =  method : java2.util2.TreeSet.remove(java.lang.Object) : var1 var2 
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=remove,line=505,id=24,direction=false
+WILL USE:
+var0 =  method : java2.util2.Collections.reverseOrder() : 
+
+
+REPLACING ALL USES OF var0 WITH var0
+NEW SEQUENCE: 
+var0 =  method : java2.util2.Collections.reverseOrder() : 
+var1 =  prim : java2.util2.Comparator:null : 
+var2 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
+var3 =  prim : java.lang.Object:null : 
+var4 =  method : java2.util2.TreeSet.remove(java.lang.Object) : var2 var3 
+
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.TreeMap,methodname=successor,line=1205,id=41,direction=false
+SEQUENCE
+var0 =  prim : java2.util2.Comparator:null : 
+var1 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
+var2 =  prim : int:0 : 
+var3 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var2 
+var4 =  prim : int:-1 : 
+var5 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var4 
+var6 =  prim : int:10 : 
+var7 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var6 
+var8 =  method : java2.util2.AbstractCollection.toString() : var1 
+
+END RECORD
+
+As source code:
+java2.util2.Comparator var0 = null;
+java2.util2.TreeSet var1 = new java2.util2.TreeSet((java2.util2.Comparator)var0);
+java.lang.Integer var2 = new java.lang.Integer((int)0);
+boolean var3 = var1.add((java.lang.Object)var2);
+java.lang.Integer var4 = new java.lang.Integer((int)-1);
+boolean var5 = var1.add((java.lang.Object)var4);
+java.lang.Integer var6 = new java.lang.Integer((int)10);
+boolean var7 = var1.add((java.lang.Object)var6);
+java.lang.String var8 = var1.toString();
+
+Variables: [var0:[null]]
+      /**
+       * Returns the successor of the specified Entry, or null if no such.
+       */
+      private Entry successor(Entry t) {
+          if (t == null)
+              return null;
+          else if (t.right != null) {
+              Entry p = t.right;
+>>            while (p.left != null)
+                  p = p.left;
+              return p;
+          } else {
+              Entry p = t.parent;
+              Entry ch = t;
+              while (p != null && ch == p.right) {
+                  ch = p;
+                  p = p.parent;
+              }
+              return p;
+          }
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeMap,methodname=successor,line=1205,id=41,direction=true
+WILL USE:
+var0 =  method : java2.util2.Collections.reverseOrder() : 
+
+
+REPLACING ALL USES OF var0 WITH var0
+NEW SEQUENCE: 
+var0 =  method : java2.util2.Collections.reverseOrder() : 
+var1 =  prim : java2.util2.Comparator:null : 
+var2 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
+var3 =  prim : int:0 : 
+var4 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var3 
+var5 =  prim : int:-1 : 
+var6 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var5 
+var7 =  prim : int:10 : 
+var8 =  method : java2.util2.TreeSet.add(java.lang.Object) : var2 var7 
+var9 =  method : java2.util2.AbstractCollection.toString() : var2 
+
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.TreeSet,methodname=addAll,line=250,id=1,direction=true
+SEQUENCE
+var0 =  prim : java2.util2.Comparator:null : 
+var1 =  cons : java2.util2.TreeSet.<init>(java2.util2.Comparator) : var0 
+var2 =  prim : int:0 : 
+var3 =  method : java2.util2.TreeSet.add(java.lang.Object) : var1 var2 
+var4 =  cons : java2.util2.TreeSet.<init>(java2.util2.Collection) : var1 
+
+END RECORD
+
+As source code:
+java2.util2.Comparator var0 = null;
+java2.util2.TreeSet var1 = new java2.util2.TreeSet((java2.util2.Comparator)var0);
+java.lang.Integer var2 = new java.lang.Integer((int)0);
+boolean var3 = var1.add((java.lang.Object)var2);
+java2.util2.TreeSet var4 = new java2.util2.TreeSet((java2.util2.Collection)var1);
+
+Variables: [var0:[object]]
+      /**
+       * Adds all of the elements in the specified collection to this set.
+       *
+       * @param c elements to be added
+       * @return <tt>true</tt> if this set changed as a result of the call.
+       *
+       * @throws ClassCastException if the elements provided cannot be compared
+       *		  with the elements currently in the set.
+       * @throws NullPointerException of the specified collection is null.
+       */
+      public boolean addAll(Collection c) {
+          // Use linear-time version if applicable
+          if (m.size()==0 && c.size() > 0 && c instanceof SortedSet && 
+              m instanceof TreeMap) {
+              SortedSet set = (SortedSet)c;
+              TreeMap map = (TreeMap)m;
+              Comparator cc = set.comparator();
+              Comparator mc = map.comparator();
+>>            if (cc==mc || (cc != null && cc.equals(mc))) {
+                  map.addAllForTreeSet(set, PRESENT);
+                  return true;
+              }
+          }
+          return super.addAll(c);
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.TreeSet,methodname=addAll,line=250,id=1,direction=false
+FAILURE
+============================================================
+START RECORD
+BRANCH 
+classname=java2.util2.Vector,methodname=addAll,line=908,id=35,direction=true
+SEQUENCE
+var0 =  prim : int:0 : 
+var1 =  cons : java2.util2.Vector.<init>(int) : var0 
+var2 =  prim : java.lang.Object:null : 
+var3 =  method : java2.util2.Vector.addElement(java.lang.Object) : var1 var2 
+var4 =  prim : int:0 : 
+var5 =  cons : java2.util2.Vector.<init>(int) : var4 
+var6 =  method : java2.util2.Vector.addElement(java.lang.Object) : var1 var5 
+var7 =  prim : int:0 : 
+var8 =  cons : java2.util2.Vector.<init>(int) : var7 
+var9 =  prim : int:0 : 
+var10 =  prim : double:10.0 : 
+var11 =  method : java2.util2.Vector.add(int,java.lang.Object) : var8 var9 var10 
+var12 =  method : java2.util2.Vector.elements() : var8 
+var13 =  prim : int:0 : 
+var14 =  method : java2.util2.Vector.insertElementAt(java.lang.Object,int) : var1 var12 var13 
+var15 =  prim : int:1 : 
+var16 =  method : java2.util2.Vector.ensureCapacity(int) : var1 var15 
+var17 =  method : java2.util2.Vector.size() : var1 
+var18 =  prim : java.lang.Object:null : 
+var19 =  method : java2.util2.Vector.removeElement(java.lang.Object) : var1 var18 
+var20 =  method : java2.util2.Vector.capacity() : var1 
+var21 =  prim : int:0 : 
+var22 =  prim : int:0 : 
+var23 =  cons : java2.util2.Vector.<init>(int) : var22 
+var24 =  prim : java.lang.Object:null : 
+var25 =  method : java2.util2.Vector.addElement(java.lang.Object) : var23 var24 
+var26 =  prim : int:0 : 
+var27 =  cons : java2.util2.Vector.<init>(int) : var26 
+var28 =  method : java2.util2.Vector.addElement(java.lang.Object) : var23 var27 
+var29 =  prim : int:0 : 
+var30 =  cons : java2.util2.Vector.<init>(int) : var29 
+var31 =  prim : int:0 : 
+var32 =  prim : double:10.0 : 
+var33 =  method : java2.util2.Vector.add(int,java.lang.Object) : var30 var31 var32 
+var34 =  method : java2.util2.Vector.elements() : var30 
+var35 =  prim : int:0 : 
+var36 =  method : java2.util2.Vector.insertElementAt(java.lang.Object,int) : var23 var34 var35 
+var37 =  prim : int:1 : 
+var38 =  method : java2.util2.Vector.ensureCapacity(int) : var23 var37 
+var39 =  method : java2.util2.Vector.size() : var23 
+var40 =  prim : java.lang.Object:null : 
+var41 =  method : java2.util2.Vector.removeElement(java.lang.Object) : var23 var40 
+var42 =  method : java2.util2.Vector.addAll(int,java2.util2.Collection) : var1 var21 var23 
+
+END RECORD
+
+As source code:
+java.lang.Integer var0 = new java.lang.Integer((int)0);
+java2.util2.Vector var1 = new java2.util2.Vector((int)var0);
+java.lang.Object var2 = null;
+var1.addElement((java.lang.Object)var2);
+java.lang.Integer var4 = new java.lang.Integer((int)0);
+java2.util2.Vector var5 = new java2.util2.Vector((int)var4);
+var1.addElement((java.lang.Object)var5);
+java.lang.Integer var7 = new java.lang.Integer((int)0);
+java2.util2.Vector var8 = new java2.util2.Vector((int)var7);
+java.lang.Integer var9 = new java.lang.Integer((int)0);
+java.lang.Double var10 = new java.lang.Double((double)10.0);
+var8.add((int)var9, (java.lang.Object)var10);
+java2.util2.Enumeration var12 = var8.elements();
+java.lang.Integer var13 = new java.lang.Integer((int)0);
+var1.insertElementAt((java.lang.Object)var12, (int)var13);
+java.lang.Integer var15 = new java.lang.Integer((int)1);
+var1.ensureCapacity((int)var15);
+int var17 = var1.size();
+java.lang.Object var18 = null;
+boolean var19 = var1.removeElement((java.lang.Object)var18);
+int var20 = var1.capacity();
+java.lang.Integer var21 = new java.lang.Integer((int)0);
+java.lang.Integer var22 = new java.lang.Integer((int)0);
+java2.util2.Vector var23 = new java2.util2.Vector((int)var22);
+java.lang.Object var24 = null;
+var23.addElement((java.lang.Object)var24);
+java.lang.Integer var26 = new java.lang.Integer((int)0);
+java2.util2.Vector var27 = new java2.util2.Vector((int)var26);
+var23.addElement((java.lang.Object)var27);
+java.lang.Integer var29 = new java.lang.Integer((int)0);
+java2.util2.Vector var30 = new java2.util2.Vector((int)var29);
+java.lang.Integer var31 = new java.lang.Integer((int)0);
+java.lang.Double var32 = new java.lang.Double((double)10.0);
+var30.add((int)var31, (java.lang.Object)var32);
+java2.util2.Enumeration var34 = var30.elements();
+java.lang.Integer var35 = new java.lang.Integer((int)0);
+var23.insertElementAt((java.lang.Object)var34, (int)var35);
+java.lang.Integer var37 = new java.lang.Integer((int)1);
+var23.ensureCapacity((int)var37);
+int var39 = var23.size();
+java.lang.Object var40 = null;
+boolean var41 = var23.removeElement((java.lang.Object)var40);
+boolean var42 = var1.addAll((int)var21, (java2.util2.Collection)var23);
+
+Variables: [var21:[0]]
+      /**
+       * Inserts all of the elements in in the specified Collection into this
+       * Vector at the specified position.  Shifts the element currently at
+       * that position (if any) and any subsequent elements to the right
+       * (increases their indices).  The new elements will appear in the Vector  
+       * in the order that they are returned by the specified Collection's
+       * iterator.
+       *
+       * @param index index at which to insert first element
+       *		    from the specified collection.
+       * @param c elements to be inserted into this Vector.
+       * @return <tt>true</tt> if this Vector changed as a result of the call.
+       * @exception ArrayIndexOutOfBoundsException index out of range (index
+       *		  &lt; 0 || index &gt; size()).
+       * @throws NullPointerException if the specified collection is null.
+       * @since 1.2
+       */
+      public synchronized boolean addAll(int index, Collection c) {
+  	modCount++;
+  	if (index < 0 || index > elementCount)
+  	    throw new ArrayIndexOutOfBoundsException(index);
+  
+          Object[] a = c.toArray();
+  	int numNew = a.length;
+  	ensureCapacityHelper(elementCount + numNew);
+  
+  	int numMoved = elementCount - index;
+>>	if (numMoved > 0)
+  	    System.arraycopy(elementData, index, elementData, index + numNew,
+  			     numMoved);
+  
+          System.arraycopy(a, 0, elementData, index, numNew);
+  	elementCount += numNew;
+  	return numNew != 0;
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.Vector,methodname=addAll,line=908,id=35,direction=false
+WILL TRY REPLACING var21 WITH VALUE 0
+WILL TRY NEGATING var21
+WILL TRY SETTING TO ZERO var21
+WILL TRY ADDING 1 var21
+WILL TRY SUBTRACTING 1 var21
+FAILURE
+
+    // I claim that this branch is unreachable because if (unitsInUse
+    // > minUnitsInUse), then the bitsets will always differ, and we
+    // won't ever faill out of the for-loop.
+
+START RECORD
+BRANCH 
+classname=java2.util2.BitSet,methodname=equals,line=955,id=90,direction=true
+SEQUENCE
+var0 =  cons : java2.util2.BitSet.<init>() : 
+var1 =  prim : int:10 : 
+var2 =  method : java2.util2.BitSet.flip(int) : var0 var1 
+var3 =  prim : int:0 : 
+var4 =  prim : int:10 : 
+var5 =  method : java2.util2.BitSet.flip(int,int) : var0 var3 var4 
+var6 =  prim : int:0 : 
+var7 =  method : java2.util2.BitSet.clear(int) : var0 var6 
+var8 =  prim : int:0 : 
+var9 =  prim : int:10 : 
+var10 =  method : java2.util2.BitSet.get(int,int) : var0 var8 var9 
+var11 =  prim : int:0 : 
+var12 =  prim : int:100 : 
+var13 =  method : java2.util2.BitSet.flip(int,int) : var10 var11 var12 
+var14 =  prim : int:1 : 
+var15 =  method : java2.util2.BitSet.set(int) : var10 var14 
+var16 =  cons : java2.util2.BitSet.<init>() : 
+var17 =  prim : int:10 : 
+var18 =  method : java2.util2.BitSet.flip(int) : var16 var17 
+var19 =  method : java2.util2.BitSet.xor(java2.util2.BitSet) : var10 var16 
+var20 =  cons : java2.util2.BitSet.<init>() : 
+var21 =  method : java2.util2.BitSet.equals(java.lang.Object) : var10 var20 
+
+END RECORD
+
+As source code:
+java2.util2.BitSet var0 = new java2.util2.BitSet();
+java.lang.Integer var1 = new java.lang.Integer((int)10);
+var0.flip((int)var1);
+java.lang.Integer var3 = new java.lang.Integer((int)0);
+java.lang.Integer var4 = new java.lang.Integer((int)10);
+var0.flip((int)var3, (int)var4);
+java.lang.Integer var6 = new java.lang.Integer((int)0);
+var0.clear((int)var6);
+java.lang.Integer var8 = new java.lang.Integer((int)0);
+java.lang.Integer var9 = new java.lang.Integer((int)10);
+java2.util2.BitSet var10 = var0.get((int)var8, (int)var9);
+java.lang.Integer var11 = new java.lang.Integer((int)0);
+java.lang.Integer var12 = new java.lang.Integer((int)100);
+var10.flip((int)var11, (int)var12);
+java.lang.Integer var14 = new java.lang.Integer((int)1);
+var10.set((int)var14);
+java2.util2.BitSet var16 = new java2.util2.BitSet();
+java.lang.Integer var17 = new java.lang.Integer((int)10);
+var16.flip((int)var17);
+var10.xor((java2.util2.BitSet)var16);
+java2.util2.BitSet var20 = new java2.util2.BitSet();
+boolean var21 = var10.equals((java.lang.Object)var20);
+
+Variables: [var12:[2]]
+      /**
+       * Compares this object against the specified object.
+       * The result is <code>true</code> if and only if the argument is 
+       * not <code>null</code> and is a <code>Bitset</code> object that has 
+       * exactly the same set of bits set to <code>true</code> as this bit 
+       * set. That is, for every nonnegative <code>int</code> index <code>k</code>, 
+       * <pre>((BitSet)obj).get(k) == this.get(k)</pre>
+       * must be true. The current sizes of the two bit sets are not compared. 
+       * <p>Overrides the <code>equals</code> method of <code>Object</code>.
+       *
+       * @param   obj   the object to compare with.
+       * @return  <code>true</code> if the objects are the same;
+       *          <code>false</code> otherwise.
+       * @see     java2.util2.BitSet#size()
+       */
+      public boolean equals(Object obj) {
+  	if (!(obj instanceof BitSet))
+  	    return false;
+  	if (this == obj)
+  	    return true;
+  
+  	BitSet set = (BitSet) obj;
+  	int minUnitsInUse = Math.min(unitsInUse, set.unitsInUse);
+  
+  	// Check units in use by both BitSets
+  	for (int i = 0; i < minUnitsInUse; i++)
+  	    if (bits[i] != set.bits[i])
+  		return false;
+  
+  	// Check any units in use by only one BitSet (must be 0 in other)
+  	if (unitsInUse > minUnitsInUse) {
+>>	    for (int i = minUnitsInUse; i<unitsInUse; i++)
+  		if (bits[i] != 0)
+  		    return false;
+  	} else {
+  	    for (int i = minUnitsInUse; i<set.unitsInUse; i++)
+  		if (set.bits[i] != 0)
+  		    return false;
+  	}
+  
+  	return true;
+      }
+
+
+GOAL BRANCH (WILL TRY TO COVER): classname=java2.util2.BitSet,methodname=equals,line=955,id=90,direction=false
+WILL TRY REPLACING var12 WITH VALUE 2
+WILL TRY NEGATING var12
+WILL TRY SETTING TO ZERO var12
+WILL TRY ADDING 1 var12
+WILL TRY SUBTRACTING 1 var12
+FAILURE
Index: systemtests/collections.txt
===================================================================
RCS file: systemtests/collections.txt
diff -N systemtests/collections.txt
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ systemtests/collections.txt	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,11 @@
+java.util.AbstractCollection
+java.util.AbstractList
+java.util.AbstractQueue
+java.util.AbstractSet
+java.util.AbstractSequentialList
+java.util.ArrayList
+java.util.Vector
+java.util.EnumSet
+java.util.HashSet
+java.util.TreeSet
+java.util.PriorityQueue
Index: systemtests/classes.txt
===================================================================
RCS file: systemtests/classes.txt
diff -N systemtests/classes.txt
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ systemtests/classes.txt	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,52 @@
+javax.xml.XMLConstants
+javax.xml.datatype.DatatypeConfigurationException
+javax.xml.datatype.DatatypeConstants
+javax.xml.datatype.DatatypeFactory
+javax.xml.datatype.Duration
+javax.xml.datatype.FactoryFinder
+javax.xml.datatype.XMLGregorianCalendar
+javax.xml.namespace.NamespaceContext
+javax.xml.namespace.QName
+javax.xml.transform.ErrorListener
+javax.xml.transform.FactoryFinder
+javax.xml.transform.OutputKeys
+javax.xml.transform.Result
+javax.xml.transform.SecuritySupport
+javax.xml.transform.Source
+javax.xml.transform.SourceLocator
+javax.xml.transform.Templates
+javax.xml.transform.Transformer
+javax.xml.transform.TransformerConfigurationException
+javax.xml.transform.TransformerException
+javax.xml.transform.TransformerFactory
+javax.xml.transform.TransformerFactoryConfigurationError
+javax.xml.transform.URIResolver
+javax.xml.transform.dom.DOMLocator
+javax.xml.transform.dom.DOMResult
+javax.xml.transform.dom.DOMSource
+javax.xml.transform.sax.SAXResult
+javax.xml.transform.sax.SAXSource
+javax.xml.transform.sax.SAXTransformerFactory
+javax.xml.transform.sax.TemplatesHandler
+javax.xml.transform.sax.TransformerHandler
+javax.xml.transform.stream.StreamResult
+javax.xml.transform.stream.StreamSource
+javax.xml.validation.Schema
+javax.xml.validation.SchemaFactory
+javax.xml.validation.SchemaFactoryFinder
+javax.xml.validation.SchemaFactoryLoader
+javax.xml.validation.TypeInfoProvider
+javax.xml.validation.Validator
+javax.xml.validation.ValidatorHandler
+javax.xml.xpath.XPath
+javax.xml.xpath.XPathConstants
+javax.xml.xpath.XPathException
+javax.xml.xpath.XPathExpression
+javax.xml.xpath.XPathExpressionException
+javax.xml.xpath.XPathFactory
+javax.xml.xpath.XPathFactoryConfigurationException
+javax.xml.xpath.XPathFactoryFinder
+javax.xml.xpath.XPathFunction
+javax.xml.xpath.XPathFunctionException
+javax.xml.xpath.XPathFunctionResolver
+javax.xml.xpath.XPathVariableResolver
Index: systemtests/RatPoly.classes
===================================================================
RCS file: systemtests/RatPoly.classes
diff -N systemtests/RatPoly.classes
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ systemtests/RatPoly.classes	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,1 @@
+ps1.RatPoly
Index: systemtests/Makefile
===================================================================
RCS file: systemtests/Makefile
diff -N systemtests/Makefile
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ systemtests/Makefile	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,283 @@
+#
+# Makefile for running Randoop experiments.
+#
+# Notable targets:
+#
+# subjects.zip - Create subject programs zip file.
+#
+# The Randoop experiments are over several "subject programs,"
+# e.g. the java collections, or daikon.
+#
+#  * Each subject program has a name. The list of names is in variable
+#    all_experiments below.
+#
+#   For each subjece program named SUBJ:
+#
+#   + The sources for the asubject programs are under
+#     $RANDOOP_HOME/systemtests/src/SUBJ.
+#
+#   + The file
+#     $RANDOOP_HOME/systemtests/experiments/SUBJ.experiment
+#     is a property file containing information necessary to
+#     compile and execute the classes under test, e.g. the
+#     sub-directory containing the sources, any auxiliary
+#     jar files, etc.
+
+include ../common.mk
+
+# Check if src.tgz has been untarred.
+# If src/README exists, it means that it has.
+# ifeq ($(wildcard src/README),)
+# $(error It appears you have not untarred src.tgz yet. Do so before continuing.)
+# endif
+
+all_experiments = \
+java_collections \
+
+exp1_subjects = java_collections javax_xml primitives logging jelly commons_collections chain math utilmde
+
+default:
+	$(error "No default target.")
+
+# Builds Randoop
+build:
+	cd .. && make build
+
+# Compiles and instruments (for tracking coverage) a subject program.
+#
+# Example concrete target: prepare-java_collections
+#
+prepare-%:
+	@java -ea -cp $(CLASSPATH) \
+	  randoop.experiments.PrepareSubjectProgram $*
+
+# Calls prepare-SUBJ on all the subject programs.
+all-prepare:
+	java -ea -cp $(CLASSPATH) \
+	  randoop.experiments.MultiMachineRunner \
+	  randoop.experiments.PrepareTargetMaker \
+	  $(exp1_subjects)
+
+############################################################
+# Calculate the size of the sequence space for each subject.
+
+calc-sequence-space:
+	java -ea -cp $(CLASSPATH) \
+	  -DRANDOOP_HOME=$(RANDOOP_HOME) \
+	  randoop.experiments.MultiMachineRunner \
+	  randoop.experiments.OneTargetPerArgument \
+	  prefix=one-subject-calc- \
+	  $(exp1_subjects)
+
+one-subject-calc-%:
+	java -ea -cp $(CLASSPATH) \
+	  randoop.experiments.CalculateSequenceSpace \
+	  $*
+
+############################################################
+# Experiment comparing 4 combinations of random generation.
+#
+# O : offline, F : feedback
+# M : memoryless, C : components
+#
+# fail: om-peanut om-java_xml (inf loop) om-utilmde (inf loop)
+
+temp3:
+	java -ea -cp $(CLASSPATH) randoop.experiments.StatsWriter temp.txt
+
+exp1_res = $(foreach exp, $(exp1_subjects), om-$(exp) oc-$(exp) fm-$(exp) fc-$(exp))
+
+show-exp1:
+	grep -v "^$$" $(exp1_res) | grep -v "#" | grep -v "ERRORS"
+
+clean-exp1:
+	rm om-* oc-* fm-* fc-*
+
+# 	  -DRANDOOP_MACHINES=potato,jicama,mangold,
+
+covratios:
+	java -ea -cp $(CLASSPATH) \
+	randoop.experiments.CalculateCovTimeRatios $(exp1_subjects)
+
+exp1:
+	java -ea -cp $(CLASSPATH) \
+	  -DRANDOOP_HOME=$(RANDOOP_HOME) \
+	  -DRANDOOP_MACHINES=jicama,mangold,radish,horseradish,onion,parsnip,peanut \
+	  randoop.experiments.MultiMachineRunner \
+	  randoop.experiments.OneTargetPerArgument \
+	  prefix=om- prefix=oc- prefix=fc- prefix=fm- \
+	  $(exp1_subjects)
+
+par-om:
+	java -ea -cp $(CLASSPATH) \
+	  -DRANDOOP_HOME=$(RANDOOP_HOME) \
+	  -DRANDOOP_MACHINES=potato,jicama,mangold,radish,horseradish,onion,parsnip,peanut \
+	  randoop.experiments.MultiMachineRunner \
+	  randoop.experiments.OneTargetPerArgument \
+	  prefix=om-0- prefix=om-1- prefix=om-2- prefix=om-3- prefix=om-4- prefix=om-5- prefix=om-6- prefix=om-7- \
+	  commons_collections
+
+par-fc:
+	java -ea -cp $(CLASSPATH) \
+	  -DRANDOOP_HOME=$(RANDOOP_HOME) \
+	  -DRANDOOP_MACHINES=potato,jicama,mangold,radish,horseradish,onion,parsnip,peanut \
+	  randoop.experiments.MultiMachineRunner \
+	  randoop.experiments.OneTargetPerArgument \
+	  prefix=fc-0- prefix=fc-1- prefix=fc-2- prefix=fc-3- prefix=fc-4- prefix=fc-5- prefix=fc-6- prefix=fc-7- \
+	  commons_collections
+
+temp:
+	java -ea \
+	-classpath /afs/csail.mit.edu/u/c/cpacheco/temp-eclipse/jrandoop/systemtests/java_collections-covinst:$(CLASSPATH) \
+	randoop.main.Main \
+	exec temp.txt
+
+temp2:
+	javac 	-classpath /afs/csail.mit.edu/u/c/cpacheco/temp-eclipse/jrandoop/systemtests/commons_collections-covinst:$(CLASSPATH) 	Temp.java
+	java 	-classpath .:/afs/csail.mit.edu/u/c/cpacheco/temp-eclipse/jrandoop/systemtests/commons_collections-covinst:$(CLASSPATH) 	Temp
+
+
+om-%:
+	java -ea -cp $(CLASSPATH) \
+	  randoop.experiments.RandoopAllClasses \
+	  --offline=true --component-based=false \
+	  $*
+
+oc-%:
+	java -ea -cp $(CLASSPATH) \
+	  randoop.experiments.RandoopAllClasses \
+	  --offline=true --component-based=true --summary=$@ \
+	  $* \
+	  > $@
+
+fc-%:
+	java -ea -cp $(CLASSPATH) \
+	  randoop.experiments.RandoopAllClasses \
+	  --offline=false --component-based=true --summary=$@ \
+	  $* \
+	  > $@
+
+fm-%:
+	java -ea -cp $(CLASSPATH) \
+	  randoop.experiments.RandoopAllClasses \
+	  --offline=false --component-based=false --summary=$@ \
+	  $* \
+	  > $@
+
+############################################################
+#
+# RANDOOP (once per class) + DF + BDGEN experiment.
+
+# Runs the entire experiment.
+all: clean prepare-java_collections all-class dfbdgen
+
+# Remove auto-generated files.
+clean:
+	-rm \
+	*.components.gz \
+	*.covmap.gz \
+	*.covreport.txt \
+	*.frontiers.gz \
+	*.frontiers.gz.output \
+	*.bdgencovmap.gz \
+	*.successes.txt \
+	*.componentsused.txt \
+	*.bdgen.output.txt
+
+
+# Calls Randoop on a single class of a subject program.
+# Example concrete target: class-java_collections-java2.util2.ArrayList
+# The above target runs Randoop on java_collection's ArrayList class.
+class-%:
+	java -ea -cp $(CLASSPATH) \
+	  randoop.experiments.RandoopOneClass $*
+
+# Calls class-SUBJ on all the subject programs.
+# To run in parallel on several machines, add the following argument:
+#
+#	  -DRANDOOP_MACHINES=potato,jicama,mangold,radish,horseradish,onion,parsnip
+all-class:
+	java -ea -cp $(CLASSPATH) \
+	  -DRANDOOP_HOME=$(RANDOOP_HOME) \
+	  -DRANDOOP_MACHINES=potato,jicama,mangold,radish,horseradish,onion,parsnip \
+	  randoop.experiments.MultiMachineRunner \
+	  randoop.experiments.RandoopOneClassTargetMaker class \
+	  $(all_experiments)
+
+#  -DRANDOOP_MACHINES=potato,potato,potato,jicama,jicama,jicama,mangold,mangold,mangold,radish,horseradish,onion,parsnip,beet,rutabaga,leek,yam,scallion
+
+parallel-df:
+	java -ea -cp $(CLASSPATH) \
+	  -DRANDOOP_HOME=$(RANDOOP_HOME) \
+	  randoop.experiments.MultiMachineRunner \
+	  randoop.experiments.OneTargetPerLine \
+	  .df- \
+	  java_collections.dftargets.txt
+
+.df-%:
+	java -ea -cp $(CLASSPATH) \
+	  randoop.experiments.DFOneFile $*
+	touch .df-$*
+
+clean-df:
+	rm .df*
+
+# 	  -DRANDOOP_MACHINES=potato,potato,potato,jicama,mangold,radish,horseradish,onion,parsnip,peanut
+parallel-gen:
+	java -ea -cp $(CLASSPATH) \
+	  -DRANDOOP_HOME=$(RANDOOP_HOME) \
+	  randoop.experiments.MultiMachineRunner \
+	  randoop.experiments.OneTargetPerLine \
+	  .gen- \
+	  java_collections.dftargets.txt
+
+.gen-%:
+	java -ea -cp $(CLASSPATH) \
+	  randoop.experiments.BDGenOneFile $*
+	touch .gen-$*
+
+clean-gen:
+	rm .gen*
+
+# make fc-java_collections
+
+dfbdgen:
+	java -ea -cp $(CLASSPATH) \
+	  randoop.experiments.DFBDGenOneClass \
+	  --skip=1 --skip=4 --skip=5 \
+	  java_collections
+
+
+############################################################
+#
+# JCute experiment targets.
+
+cute:
+	-rm -r jcute/src/java2/
+	cd randoop-instr && cp -r . ../jcute/src/
+	cd jcute && ./jcutec src/ src/dstest/MTVectorTest.java dstest.MTVectorTest -sequential
+	cd jcute && ./jcute dstest.MTVectorTest -i 20 -p 1 > vector.output.txt
+	java -ea -cp randoop-instr:.:$(CLASSPATH) randoop.experiments.CountCoverage jcute/vector.output.txt
+
+
+jcuteds:
+	java -ea -Xmx1700m -cp src/java_collections:$(CLASSPATH) \
+	  randoop.experiments.JCuteDataStructuresExp \
+	  experiments/jcute/arraylist.methods \
+	  experiments/jcute/arraylist.coveragemethods \
+	  cobertura.ser
+
+############################################################
+#
+# Create zip file of subject programs.
+
+subjects.zip:
+	-rm -r tempzip
+	mkdir tempzip
+	mkdir tempzip/src
+	cp -r src/ tempzip/src
+	find tempzip/ -name "CVS" | xargs rm -r
+	find tempzip/ -name "*.class" | xargs rm
+	cd tempzip && zip -r subjects src
+	mv tempzip/subjects.zip .
+	rm -r tempzip
Index: systemtests/carlos.mk
===================================================================
RCS file: systemtests/carlos.mk
diff -N systemtests/carlos.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ systemtests/carlos.mk	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,34 @@
+
+# Carlos's scratch makefile.
+
+include ../common.mk
+
+daikon:
+	make class-daikon-daikon.inv.binary.twoScalar.LinearBinaryCore
+
+daikon-df:
+	make df-daikon-daikon.inv.binary.twoScalar.LinearBinaryCore
+
+arraylist-prep:
+	make prepare-java_collections
+
+arraylist:
+	make class-java_collections-java2.util2.HashMap
+
+arraylist-df:
+	make df-java_collections-java2.util2.HashMap
+
+arraylist-genbd:
+	make genbd-java_collections-java2.util2.HashMap
+
+execute:
+	java -ea -classpath $(RANDOOP_HOME)/systemtests/java_collections-covinst:$(CLASSPATH) \
+	   randoop.experiments.Execute \
+	   resources/df-bdgen-covclasses.txt \
+	   carlos-temp.txt
+
+stats:
+	java -ea -classpath $(RANDOOP_HOME)/systemtests/java_collections-covinst:$(CLASSPATH) \
+	   randoop.main.PrintStats \
+	   resources/df-bdgen-covclasses.txt \
+	   java_collections.stats.ser
Index: src/randoop/experiments/TempStatsComputer.java
===================================================================
RCS file: src/randoop/experiments/TempStatsComputer.java
diff -N src/randoop/experiments/TempStatsComputer.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/randoop/experiments/TempStatsComputer.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,40 @@
+package randoop.experiments;
+
+import randoop.util.Histogram;
+
+public class TempStatsComputer implements StatsComputer {
+
+  private static Histogram<Integer> netsize_hist = new Histogram<Integer>();  
+
+  private static Histogram<Integer> totalnodes_hist = new Histogram<Integer>();  
+  
+  private static Histogram<String> classifs_hist = new Histogram<String>();  
+
+  public void processOneRecord(StatsWriter writer) {
+    int bin = bin(writer.size);
+    netsize_hist.addOneToCount(bin);
+    totalnodes_hist.addToCount(bin, writer.size);
+    
+    for(int i = 0 ; i < writer.numclassifs ; i++) {
+      classifs_hist.addOneToCount(writer.classifNames[i]);
+    }
+  }
+
+  public String results() {
+    StringBuilder b = new StringBuilder();
+    b.append("net size histogram: " + netsize_hist.toStringSortedByKey() + "\n");
+    b.append("total nodes histogram: " + totalnodes_hist.toStringSortedByKey() + "\n");
+    b.append("total classifs histogram: " + classifs_hist.toStringSortedByKey() + "\n");
+    return b.toString();
+  }
+  
+  // bad code clone...
+  private static int bin(int nodes) {
+    for (int bin = 5 ; bin < 30 ; bin = bin + 5) {
+      if (nodes <= bin) {
+        return bin;
+      }
+    }
+    return 30;
+  }
+}
Index: src/randoop/experiments/StatsComputer.java
===================================================================
RCS file: src/randoop/experiments/StatsComputer.java
diff -N src/randoop/experiments/StatsComputer.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/randoop/experiments/StatsComputer.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,9 @@
+package randoop.experiments;
+
+public interface StatsComputer {
+  
+  void processOneRecord(StatsWriter writer);
+  
+  String results();
+
+}
Index: src/randoop/experiments/SizeEqualizer.java
===================================================================
RCS file: src/randoop/experiments/SizeEqualizer.java
diff -N src/randoop/experiments/SizeEqualizer.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/randoop/experiments/SizeEqualizer.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,40 @@
+package randoop.experiments;
+
+import randoop.ExecutableSequence;
+import randoop.util.Histogram;
+
+public class SizeEqualizer {
+  
+  private static final int maxbin = 30;
+  private static final int binsize = 5;
+  
+  public Histogram<Integer> hist;
+  
+  public SizeEqualizer() {
+    hist = new Histogram<Integer>();
+  }
+
+  public boolean add(ExecutableSequence s) {
+    int size = s.executedSize();
+    int bin = bin(size);
+    if (bin == maxbin) {
+      hist.addToCount(maxbin, size);
+      return true;
+    }
+    if (hist.getCount(bin) < hist.getCount(maxbin)) {
+      hist.addToCount(bin, size);
+      return true;
+    }
+    return false;
+  }
+  
+  private int bin(int nodes) {
+    for (int bin = binsize ; bin < maxbin ; bin = bin + binsize) {
+      if (nodes <= bin) {
+        return bin;
+      }
+    }
+    return maxbin;
+  }
+  
+}
Index: thoughts.txt
===================================================================
RCS file: thoughts.txt
diff -N thoughts.txt
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ thoughts.txt	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,11 @@
+
+* Forward vs. backward
+
+Forward advantages:
+  + Can execute as sequence is built - avoid bad paths.
+
+Backward advantages:
+  + More directed.
+  + More fair towards all methods.
+
+* Trees vs. dags
Index: systemtests/.cvsignore
===================================================================
RCS file: systemtests/.cvsignore
diff -N systemtests/.cvsignore
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ systemtests/.cvsignore	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,67 @@
+src
+debug
+*.classlist.txt
+log.txt
+sources.txt
+dataflow.ser.output
+dataflow.ser
+joe_experiment.tex
+*.results.tex
+TestOffline*.class
+TestOffline*.java
+TestOnline*.java
+TestOnline*.class
+RandoopTest*.java
+randoop-instr
+*-covinst
+*-scratch
+*.ser
+*.output
+RandoopTest*.class
+*.dfin.txt.gz
+*.covinstclasslist.txt
+*.cov.txt
+*.bdgen.txt
+java_collections.bdgen.log.txt
+*.bdgen.output.txt
+*.ser.gz
+*.covmap.gz
+*.components.gz
+*.covreport.txt
+*.frontiers.gz
+dataflow.txt
+*.componentsused.txt
+*.successes.txt
+*frontier*.gz
+*.allfrontiers.txt
+hs_err_pid*.log
+*dftargets.txt
+temp.log
+hi!
+frontier*.gz.result
+frontier*.gz.genoutput.txt
+*.log.txt
+randoop*.tmp
+*fc.summary
+.df*
+.gen*
+org.apache.commons.jelly.impl.TextScript*
+org.apache.commons.jelly.XMLOutput*
+org.apache.commons.jelly.expression.*
+org.apache.commons.jelly.impl.*
+fc-*
+oc-*
+om-*
+fm-*
+temp*
+trash*
+tmp*
+jcute
+*.sequencespace
+java.hprof.txt
+frontier*.genoutput.txt
+frontier*.result
+Temp*
+*.summary
+*.jpg
+null*
Index: systemtests/RatPoly.pure
===================================================================
RCS file: systemtests/RatPoly.pure
diff -N systemtests/RatPoly.pure
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ systemtests/RatPoly.pure	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,10 @@
+ps1.RatPoly.coeff(int) RC 0
+ps1.RatPoly.isNaN() RC
+ps1.RatPoly.degree() RC
+ps1.RatPoly.printTerm(int,java.lang.StringBuffer) RC 0
+ps1.RatPoly.printCoeff(ps1.RatNum,java.lang.StringBuffer,int) RC 0 2
+ps1.RatPoly.isZero() RC
+ps1.RatPoly.pack() RC
+ps1.RatPoly.eval(double) RC 0
+ps1.RatPoly.unparse() RC
+ps1.RatPoly.toString() RC
