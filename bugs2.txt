cpacheco@horseradish:~$ cd temp-eclipse/jrandoop/
cpacheco@horseradish:~/temp-eclipse/jrandoop$ ls
CVS  ant-macros.xml  bin  build.xml  command.txt  dist	doc  lib  src  tests
cpacheco@horseradish:~/temp-eclipse/jrandoop$ ant export
Buildfile: build.xml

init:

clean:

dirtybuild:
    [mkdir] Created dir: /afs/csail.mit.edu/u/c/cpacheco/temp-eclipse/jrandoop/testclasses-bin
     [echo] compiling
    [javac] Compiling 19 source files to /afs/csail.mit.edu/u/c/cpacheco/temp-eclipse/jrandoop/bin
     [echo] copy resource files to bin directory

build:

export:
   [delete] Deleting: /afs/csail.mit.edu/u/c/cpacheco/temp-eclipse/jrandoop/dist/randoop.jar
      [jar] Building jar: /afs/csail.mit.edu/u/c/cpacheco/temp-eclipse/jrandoop/dist/randoop.jar

BUILD SUCCESSFUL
Total time: 32 seconds
cpacheco@horseradish:~/temp-eclipse/jrandoop$ ls *.xml
ant-macros.xml	build.xml
cpacheco@horseradish:~/temp-eclipse/jrandoop$ ls
CVS		bin	   command.txt	doc  src	      tests
ant-macros.xml	build.xml  dist		lib  testclasses-bin
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main
Randoop for Java version 0.1.

Randoop  is a command-line tool that creates unit tests for Java. It supports
various commands, documented below. For more high-level
documentation please refer to the online manual at 
http://people.csail.mit.edu/cpacheco/randoop/

Type `help' followed by a command name to see documentation.

Commands:

genfailures -- Attempts to generate contract-violating unit tests for
        a set of classes.

genregressions -- Attempts to generate regression unit tests for a set
        of classes.

help -- Displays a help message for a given command.


cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive
TIME=100,SEQS=1000000
You must specify some classes to test. Use the `--classlist' or `--testclass' options.
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
.....................................................cpacheco@horseradish:~/temp-eclipse/jrandoop$ 
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=30 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
...............................cpacheco@horseradish:~/temp-eclipse/jrandoop$ 
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=30 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@18e3e60]}
Throwable thrown while handling command:java.lang.RuntimeException: java.io.IOException: Stream closed
java.lang.RuntimeException: java.io.IOException: Stream closed
	at randoop.sequence.generators.NaiveRandomGenerator.extendRandomly(NaiveRandomGenerator.java:350)
	at randoop.sequence.generators.NaiveRandomGenerator.generateSequences(NaiveRandomGenerator.java:230)
	at randoop.main.commands.GenInputsNaive.handle(GenInputsNaive.java:79)
	at randoop.main.Main.nonStaticMain(Main.java:88)
	at randoop.main.Main.main(Main.java:50)
Caused by: java.io.IOException: Stream closed
	at java.io.BufferedInputStream.getBufIfOpen(BufferedInputStream.java:145)
	at java.io.BufferedInputStream.read(BufferedInputStream.java:308)
	at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:264)
	at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306)
	at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158)
	at java.io.InputStreamReader.read(InputStreamReader.java:167)
	at java.io.BufferedReader.fill(BufferedReader.java:136)
	at java.io.BufferedReader.readLine(BufferedReader.java:299)
	at java.io.BufferedReader.readLine(BufferedReader.java:362)
	at randoop.sequence.generators.NaiveRandomGenerator.extendRandomly(NaiveRandomGenerator.java:347)
	... 4 more
Randoop failed.
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=30 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3]}
0

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41]}
Throwable thrown while handling command:java.lang.RuntimeException: java.io.IOException: Stream closed
java.lang.RuntimeException: java.io.IOException: Stream closed
	at randoop.sequence.generators.NaiveRandomGenerator.extendRandomly(NaiveRandomGenerator.java:351)
	at randoop.sequence.generators.NaiveRandomGenerator.generateSequences(NaiveRandomGenerator.java:230)
	at randoop.main.commands.GenInputsNaive.handle(GenInputsNaive.java:79)
	at randoop.main.Main.nonStaticMain(Main.java:88)
	at randoop.main.Main.main(Main.java:50)
Caused by: java.io.IOException: Stream closed
	at java.io.BufferedInputStream.getInIfOpen(BufferedInputStream.java:134)
	at java.io.BufferedInputStream.available(BufferedInputStream.java:381)
	at randoop.sequence.generators.NaiveRandomGenerator.extendRandomly(NaiveRandomGenerator.java:347)
	... 4 more
Randoop failed.
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=30 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3]}
0

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41]}
Throwable thrown while handling command:java.lang.RuntimeException: java.io.IOException: Stream closed
java.lang.RuntimeException: java.io.IOException: Stream closed
	at randoop.sequence.generators.NaiveRandomGenerator.readLine(NaiveRandomGenerator.java:406)
	at randoop.sequence.generators.NaiveRandomGenerator.extendRandomly(NaiveRandomGenerator.java:345)
	at randoop.sequence.generators.NaiveRandomGenerator.generateSequences(NaiveRandomGenerator.java:230)
	at randoop.main.commands.GenInputsNaive.handle(GenInputsNaive.java:79)
	at randoop.main.Main.nonStaticMain(Main.java:88)
	at randoop.main.Main.main(Main.java:50)
Caused by: java.io.IOException: Stream closed
	at java.io.BufferedInputStream.getInIfOpen(BufferedInputStream.java:134)
	at java.io.BufferedInputStream.available(BufferedInputStream.java:381)
	at randoop.sequence.generators.NaiveRandomGenerator.readLine(NaiveRandomGenerator.java:402)
	... 5 more
Randoop failed.
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=30 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08, randoop.util.TypeToObjectMap$HotPotato@10655dd], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08, randoop.util.TypeToObjectMap$HotPotato@10655dd], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2], class java.util.Collections$CopiesList=[randoop.util.TypeToObjectMap$HotPotato@16df84b]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08, randoop.util.TypeToObjectMap$HotPotato@10655dd], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2, randoop.util.TypeToObjectMap$HotPotato@1f6f296], class java.util.Collections$CopiesList=[randoop.util.TypeToObjectMap$HotPotato@16df84b]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08, randoop.util.TypeToObjectMap$HotPotato@10655dd], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f, randoop.util.TypeToObjectMap$HotPotato@1b3f829], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2, randoop.util.TypeToObjectMap$HotPotato@1f6f296], class java.util.Collections$CopiesList=[randoop.util.TypeToObjectMap$HotPotato@16df84b]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08, randoop.util.TypeToObjectMap$HotPotato@10655dd], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f, randoop.util.TypeToObjectMap$HotPotato@1b3f829], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2, randoop.util.TypeToObjectMap$HotPotato@1f6f296], class java.util.Collections$CopiesList=[randoop.util.TypeToObjectMap$HotPotato@16df84b], class java.util.Collections$1=[randoop.util.TypeToObjectMap$HotPotato@134e4fb]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08, randoop.util.TypeToObjectMap$HotPotato@10655dd], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f, randoop.util.TypeToObjectMap$HotPotato@1b3f829, randoop.util.TypeToObjectMap$HotPotato@142a80d], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2, randoop.util.TypeToObjectMap$HotPotato@1f6f296], class java.util.Collections$CopiesList=[randoop.util.TypeToObjectMap$HotPotato@16df84b], class java.util.Collections$1=[randoop.util.TypeToObjectMap$HotPotato@134e4fb]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08, randoop.util.TypeToObjectMap$HotPotato@10655dd], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f, randoop.util.TypeToObjectMap$HotPotato@1b3f829, randoop.util.TypeToObjectMap$HotPotato@142a80d], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2, randoop.util.TypeToObjectMap$HotPotato@1f6f296], class java.util.Collections$CopiesList=[randoop.util.TypeToObjectMap$HotPotato@16df84b, randoop.util.TypeToObjectMap$HotPotato@1e87719], class java.util.Collections$1=[randoop.util.TypeToObjectMap$HotPotato@134e4fb]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c, randoop.util.TypeToObjectMap$HotPotato@c791b9], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08, randoop.util.TypeToObjectMap$HotPotato@10655dd], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f, randoop.util.TypeToObjectMap$HotPotato@1b3f829, randoop.util.TypeToObjectMap$HotPotato@142a80d], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2, randoop.util.TypeToObjectMap$HotPotato@1f6f296], class java.util.Collections$CopiesList=[randoop.util.TypeToObjectMap$HotPotato@16df84b, randoop.util.TypeToObjectMap$HotPotato@1e87719], class java.util.Collections$1=[randoop.util.TypeToObjectMap$HotPotato@134e4fb]}

@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3], class java.lang.Boolean=[randoop.util.TypeToObjectMap$HotPotato@1a5ab41, randoop.util.TypeToObjectMap$HotPotato@1add2dd, randoop.util.TypeToObjectMap$HotPotato@1764be1], class java.util.Collections$EmptyMap=[randoop.util.TypeToObjectMap$HotPotato@194ca6c, randoop.util.TypeToObjectMap$HotPotato@c791b9], class java.util.Collections$UnmodifiableSet=[randoop.util.TypeToObjectMap$HotPotato@16f0472, randoop.util.TypeToObjectMap$HotPotato@5d173, randoop.util.TypeToObjectMap$HotPotato@edc3a2], class java.lang.Integer=[randoop.util.TypeToObjectMap$HotPotato@1172e08, randoop.util.TypeToObjectMap$HotPotato@10655dd], class java.util.Collections$SynchronizedMap=[randoop.util.TypeToObjectMap$HotPotato@4a5ab2], class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@1d9dc39], class java.util.Collections$SingletonMap=[randoop.util.TypeToObjectMap$HotPotato@133796], class java.util.Collections$ReverseComparator2=[randoop.util.TypeToObjectMap$HotPotato@60420f, randoop.util.TypeToObjectMap$HotPotato@1b3f829, randoop.util.TypeToObjectMap$HotPotato@142a80d], class java.util.Collections$SingletonList=[randoop.util.TypeToObjectMap$HotPotato@186c6b2, randoop.util.TypeToObjectMap$HotPotato@1f6f296], class java.util.Collections$CopiesList=[randoop.util.TypeToObjectMap$HotPotato@16df84b, randoop.util.TypeToObjectMap$HotPotato@1e87719], class java.util.Collections$1=[randoop.util.TypeToObjectMap$HotPotato@134e4fb], class java.util.TreeSet=[randoop.util.TypeToObjectMap$HotPotato@1bbd23f]}

.@@@entrySet:{class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@193c0cf]}

@@@entrySet:{class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@193c0cf], class java.util.Collections$SingletonSet=[randoop.util.TypeToObjectMap$HotPotato@1e57e8f]}

@@@entrySet:{class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@193c0cf], class java.util.Collections$SingletonSet=[randoop.util.TypeToObjectMap$HotPotato@1e57e8f], class java.util.TreeSet=[randoop.util.TypeToObjectMap$HotPotato@bad8a8]}

@@@entrySet:{class java.util.Collections$ReverseComparator=[randoop.util.TypeToObjectMap$HotPotato@193c0cf], class java.util.Collections$SingletonSet=[randoop.util.TypeToObjectMap$HotPotato@1e57e8f], class java.util.TreeSet=[randoop.util.TypeToObjectMap$HotPotato@bad8a8], class java.util.Collections$UnmodifiableSortedSet=[randoop.util.TypeToObjectMap$HotPotato@b9e45a]}

cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=30 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3]}

cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=30 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
@@@entrySet:{class java.util.Collections$EmptySet=[randoop.util.TypeToObjectMap$HotPotato@7a78d3]}
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=30 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
.........BUG!
....BUG!
....BUG!
..................BUG!
....BUG!
.....BUG!
........BUG!
.......BUG!
...BUG!
.......BUG!
...........
....BUG!
............BUG!
...BUG!
.............BUG!
....BUG!
...BUG!
.....BUG!
......BUG!
..cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=30 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
.........1
....2
....1
..................1
....1
.....1
........2
.......1
...1
.......1
...........
....1
............1
...1
.............2
....1
...1
.....1
......2
...1
.......2
.......2
..1
.....1
......
.1
.......2
.......1
........cpacheco@horseradish:~/temp-eclipse/jrandoop$ 
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=100 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
2
...4
.1
..1
...2
.6
..2
....2
.1
.2
.2
.1
.2
......2
.4
..1
.1
...1
..1
.2
....2
.1
.2
.2
..1
.4
........1
...1
..1
..cpacheco@horseradish:~/temp-eclipse/jrandoop$ 
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=100 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
...randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.EqualsNotReflexive
..randoop.contract.unary.EqualsNotReflexive
...randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
randoop.contract.unary.ToStringThrowsException
randoop.contract.unary.ToStringThrowsException
..randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
....randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.EqualsNotReflexive
......randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.ToStringThrowsException
randoop.contract.unary.ToStringThrowsException
randoop.contract.unary.ToStringThrowsException
randoop.contract.unary.ToStringThrowsException
..randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.EqualsNotReflexive
...randoop.contract.unary.EqualsNotReflexive
..randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
....randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
..randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
randoop.contract.unary.ToStringThrowsException
........randoop.contract.unary.ToStringThrowsException
...randoop.contract.unary.HashcodeThrowsException
..randoop.contract.unary.HashcodeThrowsException
...randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
..randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
..randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
...randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
..randoop.contract.unary.EqualsNotReflexive
..randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
..randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.EqualsNotReflexive
...
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
...randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
....randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
...randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
...randoop.contract.unary.EqualsNotReflexive
..randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
randoop.contract.unary.ToStringThrowsException
.cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --testclass=java.util.TreeSet --testclass=java.util.Collections --maxsize=1000 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
.
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
randoop.contract.unary.ToStringThrowsException
.cpacheco@horseradish:~/temp-eclipse/jrandoop$ 
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist= bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=100 --randomseed=2
ERROR while parsing command-line arguments (will exit): Unrecognized arguments: [bin/joe/test/resources/java.util.classlist.java1.6.txt]
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=100 --randomseed=2
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
java.util.NoSuchElementException
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at randoop.reflectionexecution.ConstructorReflectionCode.runReflectionCodeRaw(ConstructorReflectionCode.java:55)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
..randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
..randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.EqualsNotReflexive
..randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
.java.util.TooManyListenersException
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at randoop.reflectionexecution.ConstructorReflectionCode.runReflectionCodeRaw(ConstructorReflectionCode.java:55)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
java.util.UnknownFormatFlagsException: Flags = [[(this Collection)]]
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at randoop.reflectionexecution.ConstructorReflectionCode.runReflectionCodeRaw(ConstructorReflectionCode.java:55)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
java.util.TooManyListenersException
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at randoop.reflectionexecution.ConstructorReflectionCode.runReflectionCodeRaw(ConstructorReflectionCode.java:55)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
java.util.UnknownFormatFlagsException: Flags = [[(this Collection)]]
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at randoop.reflectionexecution.ConstructorReflectionCode.runReflectionCodeRaw(ConstructorReflectionCode.java:55)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
..java.util.EmptyStackException
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at randoop.reflectionexecution.ConstructorReflectionCode.runReflectionCodeRaw(ConstructorReflectionCode.java:55)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
.java.util.UnknownFormatFlagsException: Flags = java.util.InputMismatchException
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at randoop.reflectionexecution.ConstructorReflectionCode.runReflectionCodeRaw(ConstructorReflectionCode.java:55)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
java.util.UnknownFormatFlagsException: Flags = java.util.InputMismatchException
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at randoop.reflectionexecution.ConstructorReflectionCode.runReflectionCodeRaw(ConstructorReflectionCode.java:55)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
java.util.UnknownFormatFlagsException: Flags = java.util.InputMismatchException
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at randoop.reflectionexecution.ConstructorReflectionCode.runReflectionCodeRaw(ConstructorReflectionCode.java:55)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
java.util.InputMismatchException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at randoop.reflectionexecution.MethodReflectionCode.runReflectionCodeRaw(MethodReflectionCode.java:73)
	at randoop.reflectionexecution.ReflectionCode.runReflectionCode(ReflectionCode.java:47)
	at randoop.reflectionexecution.RunnerThread.executeReflectionCode(RunnerThread.java:49)
	at randoop.reflectionexecution.RunnerThread.run(RunnerThread.java:42)
.cpacheco@horseradish:~/temp-eclipse/jrandoop$ 
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=100 --randomseed=2 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
..randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
..randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.EqualsNotReflexive
..randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
......randoop.contract.unary.HashcodeThrowsException
..randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.ToStringThrowsException
......randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
...randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
....randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.HashcodeThrowsException
..randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
...randoop.contract.unary.HashcodeThrowsException
.randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.randoop.contract.unary.HashcodeThrowsException
...randoop.contract.unary.HashcodeThrowsException
randoop.contract.unary.ToStringThrowsException
.cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=100 --randomseed=2 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
cpacheco@horseradish:~/temp-eclipse/jrandoop$ 
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=10 --randomseed=2 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
................................................................................
.....................................................................randoop.contract.unary.EqualsNotReflexive
...........
................................................................................
................................................................................
................................................................................
.............................................................................cpacheco@horseradish:~/temp-eclipse/jrandoop$ 
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=100 --randomseed=2 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
cpacheco@horseradish:~/temp-eclipse/jrandoop$ 
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=100 --randomseed=3 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
randoop.contract.unary.EqualsNotReflexive
.randoop.contract.unary.EqualsNotReflexive
..cpacheco@horseradish:~/temp-eclipse/jrandoop$ 
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=30 --randomseed=3 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
................................randoop.contract.unary.EqualsNotReflexive
..................................randoop.contract.unary.EqualsNotReflexive
...........randoop.contract.unary.EqualsNotReflexive
...
..............................................randoop.contract.unary.EqualsNotReflexive
.....randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.EqualsNotReflexive
.......................randoop.contract.unary.EqualsNotReflexive
randoop.contract.binary.EqualsNotSymmetric
randoop.contract.binary.EqualsNotSymmetric
randoop.contract.binary.EqualsNotSymmetric
randoop.contract.binary.EqualsNotSymmetric
......
.............................................................randoop.contract.unary.EqualsNotReflexive
.......randoop.contract.unary.EqualsNotReflexive
............
.................................randoop.contract.unary.EqualsNotReflexive
........................randoop.contract.unary.EqualsNotReflexive
.....randoop.contract.unary.EqualsNotReflexive
................randoop.contract.unary.EqualsNotReflexive
..
.............................randoop.contract.unary.EqualsNotReflexive
randoop.contract.unary.EqualsNotReflexive
..............................randoop.contract.unary.EqualsNotReflexive
.....................
...........................randoop.contract.unary.EqualsNotReflexive
.....randoop.contract.unary.EqualsNotReflexive
.......randoop.contract.unary.EqualsNotReflexive
..randoop.contract.unary.EqualsNotReflexive
...........cpacheco@horseradish:~/temp-eclipse/jrandoop$ 
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=200 --randomseed=5 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
cpacheco@horseradish:~/temp-eclipse/jrandoop$ 
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=200 --randomseed=5 2>trash.txt --usethreads
ERROR while parsing command-line arguments (will exit): unknown argument '--usethreads'
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=200 --randomseed=5 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
................................................................................
.............................................cpacheco@horseradish:~/temp-eclipse/jrandoop$ 
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=200 --randomseed=5 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
............cpacheco@horseradish:~/temp-eclipse/jrandoop$ 
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=200 --randomseed=7 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
..
cpacheco@horseradish:~/temp-eclipse/jrandoop$ cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=50 --randomseed=7 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
.............................................................................randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
...
................................................................................
...............................cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=50 --randomseed=7 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
.............................................................................randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
***

0: java.util.ArrayList.<init>() APPLIED TO []
1: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-1, -1]
2: java.util.ArrayList.add(java.lang.Object) APPLIED TO [-2, -1]
3: java.util.Collections.sort(java.util.List) APPLIED TO [-3]
4: java.util.TreeSet.<init>(java.util.Collection) APPLIED TO [-4]
5: java.util.ArrayList.indexOf(java.lang.Object) APPLIED TO [-5, -3]
6: java.util.List.retainAll(java.util.Collection) APPLIED TO [-6, -6]
7: java.util.Collection.containsAll(java.util.Collection) APPLIED TO [-3, -7]
8: java.util.Set.equals(java.lang.Object) APPLIED TO [-4, -7]
9: java.util.TreeSet.<init>(java.util.SortedSet) APPLIED TO [-5]
10: java.util.List.subList(int,int) APPLIED TO [-10, -5, -5]
11: java.util.AbstractCollection.toString() APPLIED TO [-11]
12: java.util.List.remove(int) APPLIED TO [-2, -7]
13: java.util.Collections.shuffle(java.util.List) APPLIED TO [-3]
14: java.util.Collection.retainAll(java.util.Collection) APPLIED TO [-10, -5]
15: java.util.TooManyListenersException.<init>() APPLIED TO []
16: java.util.SortedSet.comparator() APPLIED TO [-7]
17: java.util.TreeSet.comparator() APPLIED TO [-13]
18: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-18, -13]
19: java.util.TreeSet.comparator() APPLIED TO [-15]
20: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-20, -11]
21: java.util.List.size() APPLIED TO [-11]
22: java.util.Collections.swap(java.util.List,int,int) APPLIED TO [-22, -17, -17]
23: java.util.AbstractCollection.toArray() APPLIED TO [-23]
24: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-24, -20]
25: java.util.TreeSet.size() APPLIED TO [-16]
26: java.util.Set.equals(java.lang.Object) APPLIED TO [-22, -11]
27: java.util.Collections.addAll(java.util.Collection,[Ljava.lang.Object;) APPLIED TO [-27, -4]
28: java.util.ArrayList.addAll(int,java.util.Collection) APPLIED TO [-28, -3, -28]
29: java.util.AbstractCollection.toString() APPLIED TO [-25]
30: java.util.Collections.replaceAll(java.util.List,java.lang.Object,java.lang.Object) APPLIED TO [-30, -26, -5]
31: java.util.List.addAll(int,java.util.Collection) APPLIED TO [-21, -6, -22]
32: java.util.Collections.synchronizedCollection(java.util.Collection) APPLIED TO [-23]
33: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-33, -24]
34: java.util.Arrays.sort([Ljava.lang.Object;) APPLIED TO [-11]
35: java.util.Collections.unmodifiableSortedSet(java.util.SortedSet) APPLIED TO [-31]
36: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-27, -36]
37: java.util.AbstractList.get(int) APPLIED TO [-37, -32]
38: java.util.Set.equals(java.lang.Object) APPLIED TO [-3, -27]
39: java.util.SimpleTimeZone.<init>(int,java.lang.String,int,int,int,int,int,int,int,int) APPLIED TO [-14, -28, -14, -34, -14, -14, -34, -34, -34, -34]
40: java.lang.Throwable.initCause(java.lang.Throwable) APPLIED TO [-25, -25]
41: java.util.SimpleTimeZone.clone() APPLIED TO [-2]
42: java.util.ArrayList.toArray() APPLIED TO [-42]
43: java.util.StringTokenizer.<init>(java.lang.String) APPLIED TO [-14]
44: java.util.SimpleTimeZone.<init>(int,java.lang.String,int,int,int,int,int,int,int,int) APPLIED TO [-19, -15, -19, -39, -19, -19, -19, -39, -39, -39]
lastStatementTypes:[class java.util.SimpleTimeZone, int, class java.lang.String, int, int, int, int, int, int, int, int]
lastStatementValues:[var44, var25, var29, var25, var5, var25, var25, var25, var5, var5, var5]
***
randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
***

0: java.util.ArrayList.<init>() APPLIED TO []
1: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-1, -1]
2: java.util.ArrayList.add(java.lang.Object) APPLIED TO [-2, -1]
3: java.util.Collections.sort(java.util.List) APPLIED TO [-3]
4: java.util.TreeSet.<init>(java.util.Collection) APPLIED TO [-4]
5: java.util.ArrayList.indexOf(java.lang.Object) APPLIED TO [-5, -3]
6: java.util.List.retainAll(java.util.Collection) APPLIED TO [-6, -6]
7: java.util.Collection.containsAll(java.util.Collection) APPLIED TO [-3, -7]
8: java.util.Set.equals(java.lang.Object) APPLIED TO [-4, -7]
9: java.util.TreeSet.<init>(java.util.SortedSet) APPLIED TO [-5]
10: java.util.List.subList(int,int) APPLIED TO [-10, -5, -5]
11: java.util.AbstractCollection.toString() APPLIED TO [-11]
12: java.util.List.remove(int) APPLIED TO [-2, -7]
13: java.util.Collections.shuffle(java.util.List) APPLIED TO [-3]
14: java.util.Collection.retainAll(java.util.Collection) APPLIED TO [-10, -5]
15: java.util.TooManyListenersException.<init>() APPLIED TO []
16: java.util.SortedSet.comparator() APPLIED TO [-7]
17: java.util.TreeSet.comparator() APPLIED TO [-13]
18: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-18, -13]
19: java.util.TreeSet.comparator() APPLIED TO [-15]
20: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-20, -11]
21: java.util.List.size() APPLIED TO [-11]
22: java.util.Collections.swap(java.util.List,int,int) APPLIED TO [-22, -17, -17]
23: java.util.AbstractCollection.toArray() APPLIED TO [-23]
24: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-24, -20]
25: java.util.TreeSet.size() APPLIED TO [-16]
26: java.util.Set.equals(java.lang.Object) APPLIED TO [-22, -11]
27: java.util.Collections.addAll(java.util.Collection,[Ljava.lang.Object;) APPLIED TO [-27, -4]
28: java.util.ArrayList.addAll(int,java.util.Collection) APPLIED TO [-28, -3, -28]
29: java.util.AbstractCollection.toString() APPLIED TO [-25]
30: java.util.Collections.replaceAll(java.util.List,java.lang.Object,java.lang.Object) APPLIED TO [-30, -26, -5]
31: java.util.List.addAll(int,java.util.Collection) APPLIED TO [-21, -6, -22]
32: java.util.Collections.synchronizedCollection(java.util.Collection) APPLIED TO [-23]
33: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-33, -24]
34: java.util.Arrays.sort([Ljava.lang.Object;) APPLIED TO [-11]
35: java.util.Collections.unmodifiableSortedSet(java.util.SortedSet) APPLIED TO [-31]
36: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-27, -36]
37: java.util.AbstractList.get(int) APPLIED TO [-37, -32]
38: java.util.Set.equals(java.lang.Object) APPLIED TO [-3, -27]
39: java.util.SimpleTimeZone.<init>(int,java.lang.String,int,int,int,int,int,int,int,int) APPLIED TO [-14, -28, -14, -34, -14, -14, -34, -34, -34, -34]
40: java.lang.Throwable.initCause(java.lang.Throwable) APPLIED TO [-25, -25]
41: java.util.SimpleTimeZone.clone() APPLIED TO [-2]
42: java.util.ArrayList.toArray() APPLIED TO [-42]
43: java.util.StringTokenizer.<init>(java.lang.String) APPLIED TO [-14]
44: java.util.SimpleTimeZone.<init>(int,java.lang.String,int,int,int,int,int,int,int,int) APPLIED TO [-19, -15, -19, -39, -19, -19, -19, -39, -39, -39]
lastStatementTypes:[class java.util.SimpleTimeZone, int, class java.lang.String, int, int, int, int, int, int, int, int]
lastStatementValues:[var44, var25, var29, var25, var5, var25, var25, var25, var5, var5, var5]
***
randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
***

0: java.util.ArrayList.<init>() APPLIED TO []
1: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-1, -1]
2: java.util.ArrayList.add(java.lang.Object) APPLIED TO [-2, -1]
3: java.util.Collections.sort(java.util.List) APPLIED TO [-3]
4: java.util.TreeSet.<init>(java.util.Collection) APPLIED TO [-4]
5: java.util.ArrayList.indexOf(java.lang.Object) APPLIED TO [-5, -3]
6: java.util.List.retainAll(java.util.Collection) APPLIED TO [-6, -6]
7: java.util.Collection.containsAll(java.util.Collection) APPLIED TO [-3, -7]
8: java.util.Set.equals(java.lang.Object) APPLIED TO [-4, -7]
9: java.util.TreeSet.<init>(java.util.SortedSet) APPLIED TO [-5]
10: java.util.List.subList(int,int) APPLIED TO [-10, -5, -5]
11: java.util.AbstractCollection.toString() APPLIED TO [-11]
12: java.util.List.remove(int) APPLIED TO [-2, -7]
13: java.util.Collections.shuffle(java.util.List) APPLIED TO [-3]
14: java.util.Collection.retainAll(java.util.Collection) APPLIED TO [-10, -5]
15: java.util.TooManyListenersException.<init>() APPLIED TO []
16: java.util.SortedSet.comparator() APPLIED TO [-7]
17: java.util.TreeSet.comparator() APPLIED TO [-13]
18: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-18, -13]
19: java.util.TreeSet.comparator() APPLIED TO [-15]
20: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-20, -11]
21: java.util.List.size() APPLIED TO [-11]
22: java.util.Collections.swap(java.util.List,int,int) APPLIED TO [-22, -17, -17]
23: java.util.AbstractCollection.toArray() APPLIED TO [-23]
24: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-24, -20]
25: java.util.TreeSet.size() APPLIED TO [-16]
26: java.util.Set.equals(java.lang.Object) APPLIED TO [-22, -11]
27: java.util.Collections.addAll(java.util.Collection,[Ljava.lang.Object;) APPLIED TO [-27, -4]
28: java.util.ArrayList.addAll(int,java.util.Collection) APPLIED TO [-28, -3, -28]
29: java.util.AbstractCollection.toString() APPLIED TO [-25]
30: java.util.Collections.replaceAll(java.util.List,java.lang.Object,java.lang.Object) APPLIED TO [-30, -26, -5]
31: java.util.List.addAll(int,java.util.Collection) APPLIED TO [-21, -6, -22]
32: java.util.Collections.synchronizedCollection(java.util.Collection) APPLIED TO [-23]
33: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-33, -24]
34: java.util.Arrays.sort([Ljava.lang.Object;) APPLIED TO [-11]
35: java.util.Collections.unmodifiableSortedSet(java.util.SortedSet) APPLIED TO [-31]
36: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-27, -36]
37: java.util.AbstractList.get(int) APPLIED TO [-37, -32]
38: java.util.Set.equals(java.lang.Object) APPLIED TO [-3, -27]
39: java.util.SimpleTimeZone.<init>(int,java.lang.String,int,int,int,int,int,int,int,int) APPLIED TO [-14, -28, -14, -34, -14, -14, -34, -34, -34, -34]
40: java.lang.Throwable.initCause(java.lang.Throwable) APPLIED TO [-25, -25]
41: java.util.SimpleTimeZone.clone() APPLIED TO [-2]
42: java.util.ArrayList.toArray() APPLIED TO [-42]
43: java.util.StringTokenizer.<init>(java.lang.String) APPLIED TO [-14]
44: java.util.SimpleTimeZone.<init>(int,java.lang.String,int,int,int,int,int,int,int,int) APPLIED TO [-19, -15, -19, -39, -19, -19, -19, -39, -39, -39]
lastStatementTypes:[class java.util.SimpleTimeZone, int, class java.lang.String, int, int, int, int, int, int, int, int]
lastStatementValues:[var44, var25, var29, var25, var5, var25, var25, var25, var5, var5, var5]
***
randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
***

0: java.util.ArrayList.<init>() APPLIED TO []
1: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-1, -1]
2: java.util.ArrayList.add(java.lang.Object) APPLIED TO [-2, -1]
3: java.util.Collections.sort(java.util.List) APPLIED TO [-3]
4: java.util.TreeSet.<init>(java.util.Collection) APPLIED TO [-4]
5: java.util.ArrayList.indexOf(java.lang.Object) APPLIED TO [-5, -3]
6: java.util.List.retainAll(java.util.Collection) APPLIED TO [-6, -6]
7: java.util.Collection.containsAll(java.util.Collection) APPLIED TO [-3, -7]
8: java.util.Set.equals(java.lang.Object) APPLIED TO [-4, -7]
9: java.util.TreeSet.<init>(java.util.SortedSet) APPLIED TO [-5]
10: java.util.List.subList(int,int) APPLIED TO [-10, -5, -5]
11: java.util.AbstractCollection.toString() APPLIED TO [-11]
12: java.util.List.remove(int) APPLIED TO [-2, -7]
13: java.util.Collections.shuffle(java.util.List) APPLIED TO [-3]
14: java.util.Collection.retainAll(java.util.Collection) APPLIED TO [-10, -5]
15: java.util.TooManyListenersException.<init>() APPLIED TO []
16: java.util.SortedSet.comparator() APPLIED TO [-7]
17: java.util.TreeSet.comparator() APPLIED TO [-13]
18: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-18, -13]
19: java.util.TreeSet.comparator() APPLIED TO [-15]
20: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-20, -11]
21: java.util.List.size() APPLIED TO [-11]
22: java.util.Collections.swap(java.util.List,int,int) APPLIED TO [-22, -17, -17]
23: java.util.AbstractCollection.toArray() APPLIED TO [-23]
24: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-24, -20]
25: java.util.TreeSet.size() APPLIED TO [-16]
26: java.util.Set.equals(java.lang.Object) APPLIED TO [-22, -11]
27: java.util.Collections.addAll(java.util.Collection,[Ljava.lang.Object;) APPLIED TO [-27, -4]
28: java.util.ArrayList.addAll(int,java.util.Collection) APPLIED TO [-28, -3, -28]
29: java.util.AbstractCollection.toString() APPLIED TO [-25]
30: java.util.Collections.replaceAll(java.util.List,java.lang.Object,java.lang.Object) APPLIED TO [-30, -26, -5]
31: java.util.List.addAll(int,java.util.Collection) APPLIED TO [-21, -6, -22]
32: java.util.Collections.synchronizedCollection(java.util.Collection) APPLIED TO [-23]
33: java.util.AbstractList.equals(java.lang.Object) APPLIED TO [-33, -24]
34: java.util.Arrays.sort([Ljava.lang.Object;) APPLIED TO [-11]
35: java.util.Collections.unmodifiableSortedSet(java.util.SortedSet) APPLIED TO [-31]
36: java.util.AbstractCollection.addAll(java.util.Collection) APPLIED TO [-27, -36]
37: java.util.AbstractList.get(int) APPLIED TO [-37, -32]
38: java.util.Set.equals(java.lang.Object) APPLIED TO [-3, -27]
39: java.util.SimpleTimeZone.<init>(int,java.lang.String,int,int,int,int,int,int,int,int) APPLIED TO [-14, -28, -14, -34, -14, -14, -34, -34, -34, -34]
40: java.lang.Throwable.initCause(java.lang.Throwable) APPLIED TO [-25, -25]
41: java.util.SimpleTimeZone.clone() APPLIED TO [-2]
42: java.util.ArrayList.toArray() APPLIED TO [-42]
43: java.util.StringTokenizer.<init>(java.lang.String) APPLIED TO [-14]
44: java.util.SimpleTimeZone.<init>(int,java.lang.String,int,int,int,int,int,int,int,int) APPLIED TO [-19, -15, -19, -39, -19, -19, -19, -39, -39, -39]
lastStatementTypes:[class java.util.SimpleTimeZone, int, class java.lang.String, int, int, int, int, int, int, int, int]
lastStatementValues:[var44, var25, var29, var25, var5, var25, var25, var25, var5, var5, var5]
***
...
........................cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=50 --randomseed=7 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
.............................................................................randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
***
java.util.ArrayList var0 = new java.util.ArrayList();
boolean var1 = var0.equals((java.lang.Object)var0);
boolean var2 = var0.add((java.lang.Object)var1);
java.util.Collections.<java.lang.Comparable>sort((java.util.List)var0);
java.util.TreeSet var4 = new java.util.TreeSet((java.util.Collection)var0);
int var5 = var0.indexOf((java.lang.Object)var2);
boolean var6 = var0.retainAll((java.util.Collection)var0);
boolean var7 = var4.containsAll((java.util.Collection)var0);
boolean var8 = var4.equals((java.lang.Object)var1);
java.util.TreeSet var9 = new java.util.TreeSet((java.util.SortedSet)var4);
java.util.List var10 = var0.subList((int)var5, (int)var5);
java.lang.String var11 = var0.toString();
java.lang.Object var12 = var10.remove((int)var5);
java.util.Collections.shuffle((java.util.List)var10);
boolean var14 = var4.retainAll((java.util.Collection)var9);
java.util.TooManyListenersException var15 = new java.util.TooManyListenersException();
java.util.Comparator var16 = var9.comparator();
java.util.Comparator var17 = var4.comparator();
boolean var18 = var0.equals((java.lang.Object)var5);
java.util.Comparator var19 = var4.comparator();
boolean var20 = var0.addAll((java.util.Collection)var9);
int var21 = var10.size();
java.util.Collections.swap((java.util.List)var0, (int)var5, (int)var5);
java.lang.Object[] var23 = var0.toArray();
boolean var24 = var0.addAll((java.util.Collection)var4);
int var25 = var9.size();
boolean var26 = var4.equals((java.lang.Object)var15);
boolean var27 = java.util.Collections.addAll((java.util.Collection)var0, (java.lang.Object[])var23);
boolean var28 = var0.addAll((int)var25, (java.util.Collection)var0);
java.lang.String var29 = var4.toString();
boolean var30 = java.util.Collections.replaceAll((java.util.List)var0, (java.lang.Object)var4, (java.lang.Object)var25);
boolean var31 = var10.addAll((int)var25, (java.util.Collection)var9);
java.util.Collection var32 = java.util.Collections.synchronizedCollection((java.util.Collection)var9);
boolean var33 = var0.equals((java.lang.Object)var9);
java.util.Arrays.sort((java.lang.Object[])var23);
java.util.SortedSet var35 = java.util.Collections.unmodifiableSortedSet((java.util.SortedSet)var4);
boolean var36 = var9.addAll((java.util.Collection)var0);
java.lang.Object var37 = var0.get((int)var5);
boolean var38 = var35.equals((java.lang.Object)var11);
java.util.SimpleTimeZone var39 = new java.util.SimpleTimeZone((int)var25, (java.lang.String)var11, (int)var25, (int)var5, (int)var25, (int)var25, (int)var5, (int)var5, (int)var5, (int)var5);
java.lang.Throwable var40 = var15.initCause((java.lang.Throwable)var15);
java.lang.Object var41 = var39.clone();
java.lang.Object[] var42 = var0.toArray();
java.util.StringTokenizer var43 = new java.util.StringTokenizer((java.lang.String)var29);
java.util.SimpleTimeZone var44 = new java.util.SimpleTimeZone((int)var25, (java.lang.String)var29, (int)var25, (int)var5, (int)var25, (int)var25, (int)var25, (int)var5, (int)var5, (int)var5);

***
randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
***
java.util.ArrayList var0 = new java.util.ArrayList();
boolean var1 = var0.equals((java.lang.Object)var0);
boolean var2 = var0.add((java.lang.Object)var1);
java.util.Collections.<java.lang.Comparable>sort((java.util.List)var0);
java.util.TreeSet var4 = new java.util.TreeSet((java.util.Collection)var0);
int var5 = var0.indexOf((java.lang.Object)var2);
boolean var6 = var0.retainAll((java.util.Collection)var0);
boolean var7 = var4.containsAll((java.util.Collection)var0);
boolean var8 = var4.equals((java.lang.Object)var1);
java.util.TreeSet var9 = new java.util.TreeSet((java.util.SortedSet)var4);
java.util.List var10 = var0.subList((int)var5, (int)var5);
java.lang.String var11 = var0.toString();
java.lang.Object var12 = var10.remove((int)var5);
java.util.Collections.shuffle((java.util.List)var10);
boolean var14 = var4.retainAll((java.util.Collection)var9);
java.util.TooManyListenersException var15 = new java.util.TooManyListenersException();
java.util.Comparator var16 = var9.comparator();
java.util.Comparator var17 = var4.comparator();
boolean var18 = var0.equals((java.lang.Object)var5);
java.util.Comparator var19 = var4.comparator();
boolean var20 = var0.addAll((java.util.Collection)var9);
int var21 = var10.size();
java.util.Collections.swap((java.util.List)var0, (int)var5, (int)var5);
java.lang.Object[] var23 = var0.toArray();
boolean var24 = var0.addAll((java.util.Collection)var4);
int var25 = var9.size();
boolean var26 = var4.equals((java.lang.Object)var15);
boolean var27 = java.util.Collections.addAll((java.util.Collection)var0, (java.lang.Object[])var23);
boolean var28 = var0.addAll((int)var25, (java.util.Collection)var0);
java.lang.String var29 = var4.toString();
boolean var30 = java.util.Collections.replaceAll((java.util.List)var0, (java.lang.Object)var4, (java.lang.Object)var25);
boolean var31 = var10.addAll((int)var25, (java.util.Collection)var9);
java.util.Collection var32 = java.util.Collections.synchronizedCollection((java.util.Collection)var9);
boolean var33 = var0.equals((java.lang.Object)var9);
java.util.Arrays.sort((java.lang.Object[])var23);
java.util.SortedSet var35 = java.util.Collections.unmodifiableSortedSet((java.util.SortedSet)var4);
boolean var36 = var9.addAll((java.util.Collection)var0);
java.lang.Object var37 = var0.get((int)var5);
boolean var38 = var35.equals((java.lang.Object)var11);
java.util.SimpleTimeZone var39 = new java.util.SimpleTimeZone((int)var25, (java.lang.String)var11, (int)var25, (int)var5, (int)var25, (int)var25, (int)var5, (int)var5, (int)var5, (int)var5);
java.lang.Throwable var40 = var15.initCause((java.lang.Throwable)var15);
java.lang.Object var41 = var39.clone();
java.lang.Object[] var42 = var0.toArray();
java.util.StringTokenizer var43 = new java.util.StringTokenizer((java.lang.String)var29);
java.util.SimpleTimeZone var44 = new java.util.SimpleTimeZone((int)var25, (java.lang.String)var29, (int)var25, (int)var5, (int)var25, (int)var25, (int)var25, (int)var5, (int)var5, (int)var5);

***
randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
***
java.util.ArrayList var0 = new java.util.ArrayList();
boolean var1 = var0.equals((java.lang.Object)var0);
boolean var2 = var0.add((java.lang.Object)var1);
java.util.Collections.<java.lang.Comparable>sort((java.util.List)var0);
java.util.TreeSet var4 = new java.util.TreeSet((java.util.Collection)var0);
int var5 = var0.indexOf((java.lang.Object)var2);
boolean var6 = var0.retainAll((java.util.Collection)var0);
boolean var7 = var4.containsAll((java.util.Collection)var0);
boolean var8 = var4.equals((java.lang.Object)var1);
java.util.TreeSet var9 = new java.util.TreeSet((java.util.SortedSet)var4);
java.util.List var10 = var0.subList((int)var5, (int)var5);
java.lang.String var11 = var0.toString();
java.lang.Object var12 = var10.remove((int)var5);
java.util.Collections.shuffle((java.util.List)var10);
boolean var14 = var4.retainAll((java.util.Collection)var9);
java.util.TooManyListenersException var15 = new java.util.TooManyListenersException();
java.util.Comparator var16 = var9.comparator();
java.util.Comparator var17 = var4.comparator();
boolean var18 = var0.equals((java.lang.Object)var5);
java.util.Comparator var19 = var4.comparator();
boolean var20 = var0.addAll((java.util.Collection)var9);
int var21 = var10.size();
java.util.Collections.swap((java.util.List)var0, (int)var5, (int)var5);
java.lang.Object[] var23 = var0.toArray();
boolean var24 = var0.addAll((java.util.Collection)var4);
int var25 = var9.size();
boolean var26 = var4.equals((java.lang.Object)var15);
boolean var27 = java.util.Collections.addAll((java.util.Collection)var0, (java.lang.Object[])var23);
boolean var28 = var0.addAll((int)var25, (java.util.Collection)var0);
java.lang.String var29 = var4.toString();
boolean var30 = java.util.Collections.replaceAll((java.util.List)var0, (java.lang.Object)var4, (java.lang.Object)var25);
boolean var31 = var10.addAll((int)var25, (java.util.Collection)var9);
java.util.Collection var32 = java.util.Collections.synchronizedCollection((java.util.Collection)var9);
boolean var33 = var0.equals((java.lang.Object)var9);
java.util.Arrays.sort((java.lang.Object[])var23);
java.util.SortedSet var35 = java.util.Collections.unmodifiableSortedSet((java.util.SortedSet)var4);
boolean var36 = var9.addAll((java.util.Collection)var0);
java.lang.Object var37 = var0.get((int)var5);
boolean var38 = var35.equals((java.lang.Object)var11);
java.util.SimpleTimeZone var39 = new java.util.SimpleTimeZone((int)var25, (java.lang.String)var11, (int)var25, (int)var5, (int)var25, (int)var25, (int)var5, (int)var5, (int)var5, (int)var5);
java.lang.Throwable var40 = var15.initCause((java.lang.Throwable)var15);
java.lang.Object var41 = var39.clone();
java.lang.Object[] var42 = var0.toArray();
java.util.StringTokenizer var43 = new java.util.StringTokenizer((java.lang.String)var29);
java.util.SimpleTimeZone var44 = new java.util.SimpleTimeZone((int)var25, (java.lang.String)var29, (int)var25, (int)var5, (int)var25, (int)var25, (int)var25, (int)var5, (int)var5, (int)var5);

***
randoop.contract.binary.EqualsHashcodeContractViolated(java.util.SimpleTimeZone)
***
java.util.ArrayList var0 = new java.util.ArrayList();
boolean var1 = var0.equals((java.lang.Object)var0);
boolean var2 = var0.add((java.lang.Object)var1);
java.util.Collections.<java.lang.Comparable>sort((java.util.List)var0);
java.util.TreeSet var4 = new java.util.TreeSet((java.util.Collection)var0);
int var5 = var0.indexOf((java.lang.Object)var2);
boolean var6 = var0.retainAll((java.util.Collection)var0);
boolean var7 = var4.containsAll((java.util.Collection)var0);
boolean var8 = var4.equals((java.lang.Object)var1);
java.util.TreeSet var9 = new java.util.TreeSet((java.util.SortedSet)var4);
java.util.List var10 = var0.subList((int)var5, (int)var5);
java.lang.String var11 = var0.toString();
java.lang.Object var12 = var10.remove((int)var5);
java.util.Collections.shuffle((java.util.List)var10);
boolean var14 = var4.retainAll((java.util.Collection)var9);
java.util.TooManyListenersException var15 = new java.util.TooManyListenersException();
java.util.Comparator var16 = var9.comparator();
java.util.Comparator var17 = var4.comparator();
boolean var18 = var0.equals((java.lang.Object)var5);
java.util.Comparator var19 = var4.comparator();
boolean var20 = var0.addAll((java.util.Collection)var9);
int var21 = var10.size();
java.util.Collections.swap((java.util.List)var0, (int)var5, (int)var5);
java.lang.Object[] var23 = var0.toArray();
boolean var24 = var0.addAll((java.util.Collection)var4);
int var25 = var9.size();
boolean var26 = var4.equals((java.lang.Object)var15);
boolean var27 = java.util.Collections.addAll((java.util.Collection)var0, (java.lang.Object[])var23);
boolean var28 = var0.addAll((int)var25, (java.util.Collection)var0);
java.lang.String var29 = var4.toString();
boolean var30 = java.util.Collections.replaceAll((java.util.List)var0, (java.lang.Object)var4, (java.lang.Object)var25);
boolean var31 = var10.addAll((int)var25, (java.util.Collection)var9);
java.util.Collection var32 = java.util.Collections.synchronizedCollection((java.util.Collection)var9);
boolean var33 = var0.equals((java.lang.Object)var9);
java.util.Arrays.sort((java.lang.Object[])var23);
java.util.SortedSet var35 = java.util.Collections.unmodifiableSortedSet((java.util.SortedSet)var4);
boolean var36 = var9.addAll((java.util.Collection)var0);
java.lang.Object var37 = var0.get((int)var5);
boolean var38 = var35.equals((java.lang.Object)var11);
java.util.SimpleTimeZone var39 = new java.util.SimpleTimeZone((int)var25, (java.lang.String)var11, (int)var25, (int)var5, (int)var25, (int)var25, (int)var5, (int)var5, (int)var5, (int)var5);
java.lang.Throwable var40 = var15.initCause((java.lang.Throwable)var15);
java.lang.Object var41 = var39.clone();
java.lang.Object[] var42 = var0.toArray();
java.util.StringTokenizer var43 = new java.util.StringTokenizer((java.lang.String)var29);
java.util.SimpleTimeZone var44 = new java.util.SimpleTimeZone((int)var25, (java.lang.String)var29, (int)var25, (int)var5, (int)var25, (int)var25, (int)var25, (int)var5, (int)var5, (int)var5);

***
...
................................................................................
.......................................cpacheco@horseradish:~/temp-eclipse/jrandoop$ javac Temp.java 
Note: Temp.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java Temp
Exception in thread "main" java.lang.IndexOutOfBoundsException: Index: 0,Size: 0
	at java.util.SubList.rangeCheck(AbstractList.java:746)
	at java.util.SubList.remove(AbstractList.java:640)
	at Temp.main(Temp.java:17)
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java -classpath lib/junit-4.3.1.jar:bin randoop.main.Main gen-inputs-naive --classlist=bin/joe/test/resources/java.util.classlist.java1.6.txt  --maxsize=10 --randomseed=7 2>trash.txt
TIME=100,SEQS=1000000
Will not use: public int java.util.AbstractMap$SimpleEntry.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumMap.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public java.lang.Object java.util.EnumMap.put(java.lang.Object,java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException
  reason: it's a bridge method
Will not use: public final int java.lang.Enum.compareTo(java.lang.Enum)
  reason: We're skipping compareTo method in enums
Will not use: public final int java.lang.Enum.hashCode()
  reason: hashCode
Will not use: public int java.lang.Enum.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.IdentityHashMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public java.lang.Object java.util.Scanner.next()
  reason: it's a bridge method
Will not use: public synchronized int java.util.SimpleTimeZone.hashCode()
  reason: hashCode
Will not use: public int java.util.UUID.compareTo(java.lang.Object)
  reason: it's a bridge method
Will not use: public int java.util.UUID.hashCode()
  reason: hashCode
Will not use: public static java.util.UUID java.util.UUID.randomUUID()
  reason: We're skipping this to get reproducibility when running java.util tests.
Will not use: public int java.util.PropertyPermission.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public static int java.util.Arrays.deepHashCode(java.lang.Object[])
  reason: deepHashCode
Will not use: public static int java.util.Arrays.hashCode(boolean[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(byte[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(char[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(double[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(float[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(int[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(java.lang.Object[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(long[])
  reason: hashCode
Will not use: public static int java.util.Arrays.hashCode(short[])
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public int java.util.BitSet.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractSet.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Set.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map$Entry.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractMap.hashCode()
  reason: hashCode
Will not use: public synchronized int java.util.Vector.hashCode()
  reason: hashCode
Will not use: public int java.util.AbstractList.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.List.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Collection.hashCode()
  reason: hashCode
Will not use: public abstract int java.util.Map.hashCode()
  reason: hashCode
.
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................randoop.contract.binary.EqualsHashcodeContractViolated(java.util.Collections$CopiesList)
***
java.util.Random var0 = new java.util.Random();
java.util.BitSet var1 = new java.util.BitSet();
int var2 = var1.cardinality();
int var3 = var0.nextInt();
java.util.TreeSet var4 = new java.util.TreeSet();
java.util.List var5 = java.util.Collections.nCopies((int)var3, (java.lang.Object)var1);

***
................
................................................................................
................................................................................
................................................................................
..............................randoop.contract.binary.EqualsHashcodeContractViolated(java.util.Collections$CopiesList)
***
java.util.Random var0 = new java.util.Random();
java.util.NoSuchElementException var1 = new java.util.NoSuchElementException();
java.util.BitSet var2 = new java.util.BitSet();
java.lang.Throwable var3 = var1.getCause();
int var4 = var0.nextInt();
var2.or((java.util.BitSet)var2);
java.lang.StackTraceElement[] var6 = var1.getStackTrace();
java.util.List var7 = java.util.Collections.nCopies((int)var4, (java.lang.Object)var4);

***
..................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
...........................randoop.contract.binary.EqualsHashcodeContractViolated(java.util.Collections$CopiesList)
***
java.util.Observable var0 = new java.util.Observable();
java.util.EmptyStackException var1 = new java.util.EmptyStackException();
java.util.Random var2 = new java.util.Random();
int var3 = var2.nextInt();
java.util.Set var4 = java.util.Collections.emptySet();
boolean var5 = var4.remove((java.lang.Object)var2);
java.util.List var6 = java.util.Collections.nCopies((int)var3, (java.lang.Object)var3);

***
.....................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
................................................................................
..........................................................................cpacheco@horseradish:~/temp-eclipse/jrandoop$ 
cpacheco@horseradish:~/temp-eclipse/jrandoop$ javac Temp.java
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java Temp
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java Temp
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java Temp
Exception in thread "main" java.lang.IllegalArgumentException: List length = -112603528
	at java.util.Collections.nCopies(Collections.java:3203)
	at Temp.main(Temp.java:10)
cpacheco@horseradish:~/temp-eclipse/jrandoop$ javac Temp.java
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java Temp
Exception in thread "main" java.lang.IllegalArgumentException: List length = -1186097780
	at java.util.Collections.nCopies(Collections.java:3203)
	at Temp.main(Temp.java:10)
cpacheco@horseradish:~/temp-eclipse/jrandoop$ java Temp
1649146609
1649146609
cpacheco@horseradish:~/temp-eclipse/jrandoop$ 
